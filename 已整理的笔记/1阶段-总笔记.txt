##########################################
Admin01                                 #
########################################
 第一阶段课程内容共19天
 云计算系统管理、 云计算应用管理、系统&服务管理进阶

 云计算系统管理	
	DAY01	开学典礼、云网络基础			
   	DAY02	Linux系统简介、安装Linux系统、Linux基本操作		
	DAY03	命令行基础、目录和文件管理			
	DAY04	管理用户和组、tar备份与恢复、cron计划任务		
	DAY05	教学环境介绍、权限和归属			
	DAY06	软件包管理、分区规划及使用、NTP时间同步	
	DAY07	LVM逻辑卷、综合串讲、综合练习		

		
 云计算应用管理	
	DAY01	Shell脚本基础、使用变量、条件测试及选择、列表式循环
	DAY02	系统安全保护、配置用户环境、防火墙策略管理			
	DAY03	ISCSI共享存储、数据库服务基础、管理表数据	
	DAY04	配置NFS共享、HTTP服务基础		
	DAY05	网页内容访问、部署动态网站	、安全Web服务	
	DAY06	综合串讲、综合练习		


 系统&服务管理进阶	
	DAY01	扩展的几个应用、发布网络YUM源、vim编辑技巧、源码编译安装	
	DAY02	KVM构建及管理、virsh控制工具、镜像管理、虚拟机快建技术
	DAY03	DNS服务基础、特殊解析、DNS子域授权、缓存DNS
	DAY04	Split分离解析、RAID磁盘阵列、进程管理、日志管理、systemctl控制
	DAY05	批量装机环境、配置PXE引导、kickstart自动应答	
	DAY06	rsync同步操作、inotify实时同步、Cobbler网络装机		
			
##################################################################################################

  准备笔记本与笔（默写），U盘（后期存储备份教学数据）
  先讲解后练习，勤奋的练习



##################################################################
一 教学环境
1.真机是Linux   账户:student  密码: 
      
2.虚拟化软件: 虚拟众多的硬件
      虚拟机被损坏,与真机无关


########################################
典型服务模式
• C/S,Client/Server架构
– 由服务器提供资源或某种功能
– 客户机使用资源或功能

##############################################
TCP/IP协议简介
• TCP/IP是最广泛支持的通信协议集合
 – 包括大量Internet应用中的标准协议
 – 支持跨网络架构、跨操作系统平台的通信

• 主机与主机之间通信的三个要素　　　　　
 – IP地址(IP address)
  – 子网掩码(subnet mask)
 – IP路由(IP router):涉及路由器

#################################################
IP地址(IP address):唯一标识网络中一个节点地址
• 地址组成(点分十进制):
– 一共32个二进制数
　11110000.00001111.10101010.11111100

   00000000.00000000.00000000.00000000
   11111111.11111111.11111111.11111111

　　 11111111 = 255

  例子： 　1.2.3.4   192.168.1.1    10.11.12.13

#################################################

为虚拟机win2008配置IP地址
利用管理员进行登录，密码为：tedu


配置IP地址：　　192.168.1.1　　子网掩码：255.255.255.0
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 属性
– 双击“Internet协议版本4(TCP/IPv4)”　　　
– 配置完成后,单击“确定”完成

查看IP地址：　
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 详细信息

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

################################################
• IP地址的分类
– A类:1 ~ 127       　网+主+主+主
– B类:128 ~ 191  　 网+网+主+主
– C类:192 ~ 223   　网+网+网+主

• 组播及科研专用
– D类:224 ~ 239 组播
– E类:240 ~ 254 科研


   192.168.1.1=只看ip地址的第一个数字,进行判别分类


################################################
IP地址由网络位与主机位，两部来组成
 网络位=座机号码的区号，标识一个网络
 主机位=编号

子网掩码：用来区分IP地址的网络位与主机位
　　　　　利用二进制的１标识网络位
　　　　　利用二进制的0标识主机位
　192.168.1.1＝11000000.10101000.00000001.00000001
                        11111111.11111111.11111111.00000000
                         255.255.255.0

　座机号码：区号－号码（编号）
　　北京：010－12345678＝北京区域，编号为12345678的座机
　　石家庄：0311－7354444＝石家庄区域,编号为7354444的座机

　区号：标识区域

　192.168.1.1　＝　192.168.1网络，编号为１的主机
　192.168.１.2　＝　192.168.１网络，编号为２的主机
　相同网络通信，网络位相同

　192.168.1.1  255.255.255.0 = 192.168.1.1/24

   192.168.1.1/24 :该IP地址有24个网络位

　1.该IP地址是哪一类 　 2.判别网络位与主机位
################################################
克隆虚拟机win2008　　　　　　　　　　
1.双击桌面windows还原,打开桌面虚拟系统管理器,双击win2008,选择查看,详情,把内存4096修改成2048,应用.
2.进行虚拟机克隆
　双击＂虚拟系统管理器＂--＞右击＂win2008＂--＞克隆--＞克隆
3. 配置二台win2008的网络参数
配置win2008的IP地址	192.168.1.10  
			子网掩码	255.255.255.0
			网关		192.168.1.254
			dns		202.106.0.20　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

配置win2008-clone的IP地址：192.168.1.20  
			子网掩码	255.255.255.0
			网关		192.168.1.254
			dns		202.106.0.20　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

################################################
采用命令方式，测试网络联通性：
　　ping　　命令
　　ping   对方IP地址　　　ping命令是双向，有去有回
　　ping 　192.168.1.20　

　　ping 　192.168.1.２　

###############################################
　ftp://172.40.50.114

###############################################
网关地址:一个网络到另一个网络的关口　（解决不同网络通信）

DNS服务器：将网站的域名解析为,对应的IP地址
  
         www.qq.com-------＞腾讯的服务器
         www.baidu.com-------＞百度的服务器

###############################################



		192.168.0.1   255.255.255.0   192.168.0.0		1
		192.168.0.2   255.255.255.0   192.168.0.0		2

		11000000.10101000.00000000.00000001
		11111111.11111111.11111111.00000000
----------------------------------------------------------------------------------
	        11000000.10101000.00000000.00000000 
		192.168.0.0

      10.0.0.1 255.0.0.0 = 10.0.0.1/8
      192.168.20.100 255.255.255.0 = 192.168.20.100/24
########################################
dmin03                                 #
########################################
牛犇
#################################################
命令行基础

什么是命令?
• Linux命令
– 用来实现某一类功能的指令或程序
   执行大多数命令,都要找到相应的程序
[root@localhost ~]# ls /usr/bin/hostname
/usr/bin/hostname    #绿色可以执行的程序
[root@localhost ~]# 

– 命令的执行依赖于解释器(默认解释器:/bin/bash)

          用户------->解释器------->内核------->硬件

[root@localhost ~]# cat /etc/shells 
/bin/sh
/bin/bash
/sbin/nologin
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh
[root@localhost ~]#
###################################################
• Linux命令的分类
– 内部命令:属于解释器的一部分
– 外部命令:解释器之外的其他程序

命令行的一般格式
• 基本用法
– 命令字        [选项]...        [参数1]    [参数2]...
    打                                  周老师 .......

查看文本文件内容
[root@localhost ~]# cat   /etc/redhat-release 
[root@localhost ~]# cat --help

[root@localhost ~]# cat -n  /etc/redhat-release 
[root@localhost ~]# cat -n  /etc/passwd

[root@localhost ~]# cat /etc/redhat-release /etc/hosts

[root@localhost ~]# ls /root /boot
[root@localhost ~]# ls --help

################################################
快速编辑技巧
• Tab键自动补全
– 可补齐命令字、选项、参数、文件路径、软件名、服务名

• 快捷键
– Ctrl + l:清空整个屏幕                                    
– Ctrl + c:废弃当前编辑的命令行(结束正在运行的命令)
– Esc + . 或 Alt + .:粘贴上一个命令的参数

[root@localhost ~]# ls /etc/hosts
/etc/hosts
[root@localhost ~]# cat Alt + .

[root@localhost ~]# cat -n Alt + .


– Ctrl + u:清空至行首
– Ctrl + w:往回删除一个单词(以空格界定)

##################################################
mount挂载操作:让目录成为设备的访问点
一  安装软件包,前提需要基本软件安装包

二 从光盘中获得软件包

三  让系统识别光盘内容

Windows系统:
        光盘文件---->光驱设备---->CD驱动器图标(访问点)
Linux系统:
        光盘文件---->光驱设备---->访问点(目录/文件夹)
              /dev/sr0
              /dev/hdc
  一切皆文件

1.图形鼠标将光盘镜像文件放入虚拟光驱设备
2.查看光驱设备
[root@localhost ~]# ls /dev/sr0
/dev/sr0
[root@localhost ~]# ls /dev/cdrom
/dev/cdrom         #青色:代表快捷方式颜色
[root@localhost ~]# 

3.命令行挂载设备
[root@localhost ~]# mkdir /dvd
[root@localhost ~]# ls /dvd
[root@localhost ~]# mount /dev/cdrom  /dvd
mount: /dev/sr0 写保护，将以只读方式挂载
[root@localhost ~]# ls /dvd/

4.卸载
[root@localhost ~]# umount /dvd/
[root@localhost ~]# ls /dvd/
[root@localhost ~]# umount /dvd/
umount: /dvd/：未挂载
[root@localhost ~]# mkdir /nsd1904
[root@localhost ~]# mount /dev/cdrom  /nsd1904
[root@localhost ~]# ls /nsd1904

注意事项:
 1.卸载,当前不要在挂载点(访问点)目录下
[root@localhost dvd]# umount /dvd/
umount: /dvd：目标忙。
        (有些情况下通过 lsof(8) 或 fuser(1) 可以
         找到有关使用该设备的进程的有用信息)
[root@localhost dvd]# 

 2.挂载允许一个设备具备多个挂载点(访问点)
 3.不允许多个设备挂载到一个挂载点(访问点)
 4.强烈建议挂载点(访问点)选择自己创建的目录

##################################################
查看及切换目录

使用pwd、cd
• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd   [目标文件夹位置]

    ~:用户的家目录
  ~user表示用户user的家目录

  /root:管理员的家目录
  /home:存放所有普通用户家目录
[root@localhost ~]# useradd tom   #创建普通用户tom
[root@localhost ~]# cd ~tom
[root@localhost tom]# pwd
/home/tom
[root@localhost tom]# useradd dc  #创建普通用户dc
[root@localhost tom]# cd ~dc
[root@localhost dc]# pwd
/home/dc
[root@localhost dc]# useradd tc   #创建普通用户tc
[root@localhost dc]# cd ~tc
[root@localhost tc]# pwd
/home/tc
[root@localhost tc]# cd ~root    #切换到root用户的家目录
[root@localhost ~]# pwd
####################################################
. 表示当前目录

####################################################
ls 列出文档及属性
• ls — List
– 格式:ls [选项]... [目录或文件名]
• 常用命令选项
– -l:以长格式显示,显示目录内容的详细属性
– -A:包括名称以 . 开头的隐藏文档
– -d:显示目录本身(而不是内容)的属性
– -h:提供易读的容量单位(K、M等)

[root@localhost ~]# ls /root
[root@localhost ~]# ls -l  /root   #显示目录内容的详细属性

[root@localhost ~]# ls -ld /root   #显示目录本身的详细属性
[root@localhost ~]# ls -ld /

[root@localhost ~]# ls -l /dev/cdrom   #显示文件详细属性
[root@localhost ~]# ls -l /etc/passwd
[root@localhost ~]# ls -l /etc/redhat-release

[root@localhost ~]# ls -l /etc/passwd
[root@localhost ~]# ls -lh /etc/passwd

[root@localhost ~]# ls -lh /boot

[root@localhost ~]# ls -A /root
[root@localhost ~]# ls -A /boot

百度搜索 EB容量单位
百度搜索 正则表达式

###################################################

使用通配符
• 针对不确定的文档名称,以特殊字符表示
– *:任意多个任意字符                
– ?:单个字符
[root@localhost ~]# ls /boot/vm*     #以vm开头
[root@localhost ~]# ls /root/a*      #以a开头
[root@localhost ~]# ls /dev/tty*     #以tty开头
 
[root@localhost ~]# ls /etc/*tab     #以tab结尾
[root@localhost ~]# ls /etc/*.conf   #以.conf结尾

[root@localhost ~]# ls /etc/r*.conf   #以r开头并且.conf结尾
[root@localhost ~]# ls /etc/*passwd*

[root@localhost ~]# ls /dev/tty?
[root@localhost ~]# ls /dev/tty??

• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略
– {a,min,xy}:多组不同的字符串,全匹配

[root@localhost ~]# ls /dev/tty[3-8]
[root@localhost ~]# ls /dev/tty[1-9]

[root@localhost ~]# ls /dev/tty{1,3,5,7,9}
[root@localhost ~]# ls /dev/tty{1,3,5,7,9,23}
[root@localhost ~]# ls /dev/tty{1,3,S0,S1}

[root@localhost ~]# ls /dev/tty{1,3,S0,haha}

#################################################
别名的定义:简化复杂命令

• 查看已设置的别名
– alias [别名名称]
• 定义新的别名
– alias 别名名称='实际执行的命令行'
• 取消已设置的别名
– unalias [别名名称]

[root@localhost ~]# hostname
localhost.localdomain
[root@localhost ~]# hn
bash: hn: 未找到命令...
[root@localhost ~]# alias hn='hostname'  #定义别名
[root@localhost ~]# hn                   #运行别名测试

[root@localhost ~]# alias        #查看当前系统有效的别名
[root@localhost ~]# unalias hn   #删除别名
[root@localhost ~]# hn
bash: hn: 未找到命令...
[root@localhost ~]# 
####################################################

mkdir 创建目录
• mkdir — Make Directory
– 格式:mkdir [-p] [/路径/]目录名...
       -p:创建父目录

[root@localhost ~]# mkdir /opt/nsd01
[root@localhost ~]# ls /opt/

[root@localhost ~]# mkdir  /opt/nsd02   /opt/nsd03
[root@localhost ~]# ls /opt/

[root@localhost ~]# mkdir -p  /vod/movie/cartoon
[root@localhost ~]# ls /

[root@localhost ~]# mkdir -p  /opt/aa/bb/cc/dd
[root@localhost ~]# ls /opt/

-R:
  递归:目录本身以及目录下所有

[root@server0 ~]# ls -R /vod       
/vod:
movie
/vod/movie:
cartoon
/vod/movie/cartoon:

#################################################
rm 删除
• rm — Remove
– 格式:rm [选项]... 文件或目录...            
• 常用命令选项
– -r、-f:递归删除(含目录)、强制删除

[root@localhost ~]# rm -rf /opt/nsd03
[root@localhost ~]# ls /opt/

[root@localhost ~]# rm -rf /opt/rh
[root@localhost ~]# ls /opt/

##################################################
mv 移动/改名
• mv — Move
– 格式: mv [选项]... 原文件...    目标路径
[root@localhost ~]# mkdir /opt/nsd01
[root@localhost ~]# touch /opt/1.txt
[root@localhost ~]# ls /opt/

[root@localhost ~]# mv /opt/1.txt /opt/nsd01/
[root@localhost ~]# ls /opt/
[root@localhost ~]# ls /opt/nsd01/

重命名:路径不变的移动
[root@localhost ~]# mv /opt/nsd01/  /opt/haha01
[root@localhost ~]# ls /opt/

[root@localhost ~]# mv /opt/haha01/ /opt/stu01
[root@localhost ~]# ls /opt/
####################################################
cp 复制
• cp — Copy
– 格式:cp [选项]... 原文件...      目标路径

• 常用命令选项
– -r:递归,复制目录时必须有此选项
1.基本用法
[root@localhost ~]# cp /etc/passwd  /opt/
[root@localhost ~]# ls /opt/

[root@localhost ~]# cp -r /home/  /opt/
[root@localhost ~]# ls /opt/

2.可以支持两个以上的参数,永远将最后一个参数做目标,其他所有参数作为源
[root@localhost ~]# cp -r  /etc/hosts  /etc/fstab /boot/   /opt/

[root@localhost ~]# ls /opt/

3.cp经常与点  . 连用,将数据复制到当前路径下
    .:当前目录

[root@localhost ~]# cd /opt/
[root@localhost opt]# pwd
[root@localhost opt]# cp -r /etc/shadow  .  
[root@localhost opt]# ls

[root@localhost /]# cd /etc/sysconfig/network-scripts/
[root@localhost network-scripts]# pwd
[root@localhost network-scripts]# cp /etc/passwd    .  
[root@localhost network-scripts]# ls

4.复制到目标路径下,可以重新命名
[root@localhost /]# rm -rf /opt/*     
[root@localhost /]# ls /opt/
[root@localhost /]# cp /etc/passwd  /opt/
[root@localhost /]# ls /opt/

[root@localhost /]# cp /etc/passwd /opt/pd
[root@localhost /]# ls /opt/

[root@localhost /]# cp -r /home/ /opt/abc
[root@localhost /]# ls /opt/

请分析下列两次复制的不同:
[root@localhost /]# rm -rf /opt/*
[root@localhost /]# cp -r /home/  /opt/redhat
           将/home目录复制到/opt/并且重命名为redhat
[root@localhost /]# cp -r /home/  /opt/redhat
           将/home目录复制到/opt/redhat目录下

##################################################
grep针对文本文件内容进行过滤

在文本文件内容进行过滤,输出包含指定字符串的行
  /etc/passwd系统级配置文件
[root@localhost /]# grep root /etc/passwd

• 常用命令选项
– -v,取反匹配
– -i,忽略大小写
[root@localhost /]# grep -v root /etc/passwd
[root@localhost /]# grep ROOT /etc/passwd
[root@localhost /]# grep -i ROOT /etc/passwd

• 常用的匹配模式
– word 包含字符串word
– ^word 以字符串word开头
– word$ 以字符串word结尾

[root@localhost /]# grep ^root /etc/passwd

[root@localhost /]# grep root$ /etc/passwd

[root@localhost /]# grep bash$ /etc/passwd

#################################################
vim命令行文本编辑器

三个模式:
     命令模式      插入模式(输入模式)    末行模式

[root@server0 ~]# vim /opt/haxi.txt

		命----i 键---->插入模式(Esc 键回到命令模式)
		令
		模
		式----:  键---->末行模式(Esc 键回到命令模式)

     末行模式 :wq 保存并退出
     末行模式 :q! 强制不保存并退出


##########################################
Admin04                                 #
########################################
#################################################
复制时出现重名,强制覆盖
在本次复制,临时取消别名
[root@A ~]# cp -r /boot/ /opt/
[root@A ~]# cp -r /boot/ /opt/

[root@A ~]# \cp -r /boot/ /opt/

#################################################

命令输出重定向
  >:覆盖重定向
  >>:追加重定向
[root@A ~]# ls --help
[root@A ~]# ls --help  > /opt/ls.txt
[root@A ~]# ls /opt/
[root@A ~]# less /opt/ls.txt 

[root@A ~]# hostname
[root@A ~]# hostname > /opt/ls.txt 
[root@A ~]# cat /opt/ls.txt

[root@A ~]# hostname >> /opt/ls.txt
[root@A ~]# cat /opt/ls.txt

[root@A ~]# echo haha
[root@A ~]# cat /opt/ls.txt     

[root@A ~]# echo 123456 >> /opt/ls.txt
[root@A ~]# cat /opt/ls.txt

[root@A ~]# echo hello > /opt/ls.txt
[root@A ~]# cat /opt/ls.txt
##################################################
   | 管道操作: 将前面命令的输出,交由后面命令处理
  
  显示文件内容/etc/passwd的8~12行
[root@A ~]# head -12 /etc/passwd | tail -5
[root@A ~]# head -12 /etc/passwd | tail -5 | cat  -n
[root@A ~]# cat -n /etc/passwd | head -12 | tail -5

[root@A ~]# ifconfig | less
[root@A ~]# ifconfig | head -2

##################################################
管理用户和组

  用户:登录操作系统,不同的用户具备不同的权限
  组:方便管理用户

  用户唯一标识: UID
  组唯一标识: GID

  管理员root的UID为0

  组的分类: 基本组(私有组)    附加组(从属组)
  原则:一个用户必须至少属于一个组
  基本组(私有组) :由系统创建与用户同名的组
  附加组(从属组):由管理员root创建的组

[root@A ~]# useradd nsd01
[root@A ~]# 组:nsd01

               附加组(从属组): caiwu   meinv  haha  jishu
###################################################
添加用户
用户基本信息存放在 /etc/passwd 文件
[root@A ~]# head -1 /etc/passwd
 root:x:0:0:root:/root:/bin/bash
 用户名:密码占位符:UID:基本组GID:用户描述信息:家目录:解释器程序
• 使用 useradd 命令
– useradd [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器、-G 附加组

[root@A ~]# useradd nsd02    #创建nsd02用户
[root@A ~]# id nsd02         #查看nsd02用户基本信息

[root@A ~]# useradd nsd03
[root@A ~]# id nsd03

[root@A ~]# useradd -u 1500 nsd04  #指定用UID值创建
[root@A ~]# id nsd04

[root@A ~]# useradd -d /opt/abc  nsd05  #指定用户家目录创建
[root@A ~]# ls /opt/
[root@A ~]# grep  nsd05  /etc/passwd

 用户名:密码占位符:UID:基本组GID:用户描述信息:家目录:解释器程序

[root@A ~]# useradd -d /opt/nsd06  nsd06 
[root@A ~]# ls /opt/
[root@A ~]# grep  nsd06  /etc/passwd

###################################################
-s 登录解释器
 /sbin/nologin:禁止登录操作系统
[root@A ~]# useradd -s /sbin/nologin nsd06
[root@A ~]# grep nsd06 /etc/passwd

-G 附加组
[root@A ~]# groupadd stugrp     #创建stugrp组
[root@A ~]# useradd -G stugrp  nsd07
[root@A ~]# id nsd07
 
[root@A ~]# useradd -G stugrp  nsd08
[root@A ~]# id nsd08

##################################################
设置登录密码
用户密码信息存放在 /etc/shadow 文件
[root@A ~]# tail -1 /etc/shadow
nsd08:$6$VjFxZ9GD$XaYwBkrcR0eVnFNZrO/om1bQKFYzlsXW.aHMCx.nOGguVde19zLyyl1jBekeU6r49UfFcvWy4sUDw8iG2OSv2.:18022:0:99999:7:::

用户名:密码加密字符串:上一次修改密码的时间

         1970-1-1~2019-5-6     18022

[root@A ~]# useradd nsd10
[root@A ~]# tail -1 /etc/shadow
nsd10:!!:18022:0:99999:7:::

第二个字段为!!,代表用户为锁定状态

• 使用 passwd 命令
– passwd [用户名]
[root@A ~]# useradd nsd08
[root@A ~]# passwd nsd08   #交互方式设置密码
更改用户 nsd08 的密码 。
新的 密码：                                #输入新的密码
无效的密码： 密码少于 8 个字符
重新输入新的 密码：                    #重新输入新的密码
passwd：所有的身份验证令牌已经成功更新。
[root@A ~]# su - nsd08      #命令行临时切换身份
[nsd08@A ~]$ passwd 
更改用户 nsd08 的密码 。
为 nsd08 更改 STRESS 密码。
（当前）UNIX 密码：              #输入旧密码
新的 密码：                            #输入新的密码
重新输入新的 密码：                #重新输入新的密码
passwd：所有的身份验证令牌已经成功更新。
[nsd08@A ~]$ exit        #退出回到root


非交互式设置密码
 echo '密码'   |   passwd  --stdin 用户名

[root@A ~]# echo 123  | passwd --stdin nsd08

[root@A ~]# echo redhat | passwd --stdin nsd08

[root@A ~]# echo 654321 | passwd --stdin nsd08

#################################################
修改用户属性
• 使用 usermod 命令
– usermod [选项]... 用户名
• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器、-G 附加组

[root@A ~]# useradd nsd11
[root@A ~]# id nsd11
[root@A ~]# grep nsd11 /etc/passwd

[root@A ~]# usermod -u 1800 -d /opt/test -s /sbin/nologin -G stugrp  nsd11

[root@A ~]# id nsd11
[root@A ~]# grep nsd11 /etc/passwd

[root@A ~]# useradd nsd13
[root@A ~]# grep nsd13 /etc/passwd
[root@A ~]# ls /home/

[root@A ~]# usermod -d  /opt/n13  nsd13
[root@A ~]# grep nsd13 /etc/passwd

[root@A ~]# ls /opt/n13
ls: 无法访问/opt/n13: 没有那个文件或目录

################################################
检查用户ID信息
• 使用 id 命令
– id 用户名

##################################################
删除用户
• 使用 userdel 命令
– userdel [-r] 用户名
   -r:连同用户家目录一并删除

[root@A ~]# ls /home/

[root@A ~]# userdel nsd01
[root@A ~]# ls /home/

[root@A ~]# id nsd01
id: nsd01: no such user
[root@A ~]# rm -rf /home/nsd01/
[root@A ~]# ls /home/

[root@A ~]# ls /home/
[root@A ~]# userdel -r nsd02
[root@A ~]# ls /home/

####################################################
管理组账号

添加组
组基本信息存放在 /etc/group 文件
[root@A ~]# grep linux /etc/group
linux:x:1802:

组名:组的密码占位符:组的编号:组成员列表

• 使用 groupadd 命令
– groupadd [-g 组ID] 组名
[root@A ~]# groupadd  linux
[root@A ~]# grep linux /etc/group

[root@A ~]# useradd natasha
[root@A ~]# useradd kaka
[root@A ~]# useradd jack
[root@A ~]# useradd xiha

管理组成员
组成员信息存放在 /etc/gshadow 文件
• 使用 gpasswd 命令
– gpasswd -a 用户名 组名
– gpasswd -d 用户名 组名

[root@A ~]# grep linux /etc/group
[root@A ~]# gpasswd -a natasha linux   #将用户加入组

[root@A ~]# grep linux /etc/group
[root@A ~]# id natasha

[root@A ~]# gpasswd -a kaka linux
[root@A ~]# grep linux /etc/group

[root@A ~]# gpasswd -a jack linux
[root@A ~]# grep linux /etc/group

[root@A ~]# gpasswd -d kaka linux    #将用户从组中删除
[root@A ~]# grep linux /etc/group

案例1:配置用户和组账号
• 新建用户 alex,其用户ID为3456,密码是flectrag           
[root@A ~]# useradd -u 3456 alex 
[root@A ~]# id alex
[root@A ~]# echo flectrag | passwd --stdin alex
• 创建下列用户、组以及组的成员关系:创建一个名为 adminuser 的组
[root@A ~]# groupadd adminuser
[root@A ~]# grep adminuser /etc/group
• 创建natasha 的用户,其属于 adminuser 组,这个组是该用户的从属组
[root@A ~]# gpasswd -a natasha adminuser
[root@A ~]# grep adminuser /etc/group
• 创建harry 的用户,其属于 adminuser 组,这个组是该用户的从属组
[root@A ~]# gpasswd -a harry adminuser
[root@A ~]# grep adminuser /etc/group
• 创建 sarah 的用户,其在系统中没有可交互的Shell(解释器),不是 adminuser 组的成员
[root@A ~]# useradd -s /sbin/nologin sarah
[root@A ~]# grep sarah /etc/passwd
• natasha 、harry、sarah 的密码都要设置为 flectrag
[root@A ~]# echo flectrag | passwd --stdin natasha
[root@A ~]# echo flectrag | passwd --stdin harry
[root@A ~]# echo flectrag | passwd --stdin sarah

###################################################
删除组
• 使用 groupdel 命令
– groupdel 组名
[root@A ~]# groupdel linux
[root@A ~]# grep linux /etc/group

###############################################
tar备份与恢复

    作用:减少占用的空间,零散的文件整理到一个压缩包

    压缩格式:
       gzip-----> .gz  
       bzip2-----> .bz2
       xz  -----> .xz

制作tar包:打包
  格式: tar  选项      /路径/压缩包的名字      /路径/源文档  .......

解包
  格式: tar  选项     /路径/压缩包的名字       /释放位置


• tar 集成备份工具
– -c:创建归档
– -x:释放归档
– -f:指定归档文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz格式的工具进行处理
– -t:显示归档中的文件清单
– -C:指定释放路径

 f选项必须放在,所有选项的最后         
制作tar包:打包

]# tar -zcf /opt/file.tar.gz  /home/ /etc/passwd
]# ls /opt/

]# tar -jcf /opt/nsd.tar.bz2  /home/  /etc/passwd
]# ls /opt/

]# tar -Jcf /opt/abc.tar.xz   /home/  /etc/passwd
]# ls /opt/

  -z:gzip压缩格式
  -j:bzip2压缩格式
  -J:xz压缩格式

[root@A ~]# mkdir /nsd02
[root@A ~]# tar -xf /opt/file.tar.gz -C /nsd02
[root@A ~]# ls /nsd02/
[root@A ~]# ls /nsd02/etc/
[root@A ~]# ls /nsd02/home/

[root@A ~]# mkdir /nsd03
[root@A ~]# tar -xf /opt/nsd.tar.bz2 -C /nsd03
[root@A ~]# ls /nsd03

[root@A ~]# tar -tf /opt/abc.tar.xz   #查看包里内容


案例2:创建一个备份包
使用 tar 工具完成以下备份任务:
– 创建一个名为 /root/backup.tar.bz2 的归档文件
– 其中包含 /usr/local 目录中的内容
– tar 归档必须使用 bzip2 进行压缩

[root@A ~]# tar -jcf /root/backup.tar.bz2 /usr/local/

[root@A ~]# ls /root/

[root@A ~]# tar -tf /root/backup.tar.bz2   #查看包里内容

#####################################################
周期性任务

cron任务概述
• 用途:按照设置的时间间隔为用户反复执行某一项固定的系统任务
• 日志文件:/var/log/crond

执行周期 配置说明
分钟 从0到59之间的整数
小时 从0到23之间的整数
日期 从1到31之间的整数
月份 从1到12之间的整数
星期 0~7之间的整数,0或7代表星期日



• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]
– 查看:crontab -l [-u 用户名]
– 清除:crontab -r [-u 用户名]

如何编写crontab任务记录 
– 分  时  日  月  周    任务命令行(绝对路径)       

   30   8   *   *   *           #每天早晨的8:30              

   30   23   *   *   5         #每周的周五晚上11:30      

   30   8   1   *    *          #每月的1号早晨的8:30   

   30   23   *   *   1-5      #周一至周五晚上11:30      

   30   23   *   *   1,3,5   #周一或周三或周五晚上11:30     

	*:匹配范围内任意时间
	,:分隔多个不连续的时间点
	-:指定连续时间范围
	/n:指定时间频率,每n ...

   1   */2   *   *   *     #每隔2个小时执行一次

   */5   *   *   *   *     #每隔5分钟执行一次

   30   23   1   *   1     #周一或每月一号 晚上11:30       

##################################################
每分钟记录当前系统时间,将系统时间每分钟写入文件/opt/time.txt
[root@A ~]# date
[root@A ~]# date >> /opt/time.txt
[root@A ~]# cat /opt/time.txt
[root@A ~]# crontab -e -u root
*  *  *  *  *   date  >>  /opt/time.txt

[root@A ~]# crontab -l -u root
[root@A ~]# cat /opt/time.txt

###################################################
[root@A ~]# crontab -e -u root
*/2  *  *  *  *  date >> /opt/time.txt
[root@A ~]# crontab -l -u root

[root@A ~]# cat /opt/time.txt
###################################################

##########################################
Admin05                                 #
########################################
erver —— 作为练习用服务器
– desktop —— 作为练习用客户机
– classroom —— 提供网关/DNS/软件素材等资源

优先开启classroom虚拟机

真机上:使用rht-vmctl辅助工具
• 控制教学用虚拟机
– 格式:rht-vmctl 控制指令 虚拟机名
– 常用控制指令:
[student@room9pc01 ~]$ rht-vmctl 　reset　 classroom
classroom [OK]
域 classroom 已开始

[student@room9pc01 ~]$ rht-vmctl　 reset　 server
server [OK]
域 server 已开始

[student@room9pc01 ~]$ rht-vmctl 　reset　 desktop
desktop [OK]
域 desktop 已开始

虚拟机server与虚拟机desktop,利用root登录密码为redhat
#################################################
字体变大：ctrl   shift   +
字体变小：ctrl   -

#################################################
虚拟机server:
  1.查看系统的版本:RHEL7.0
  2.查看eth0网卡的IP地址:172.25.0.11/24  
  3.查看主机名:server0.example.com

虚拟机desktop:
  1.查看系统的版本:RHEL7.0
  2.查看eth0网卡的IP地址:172.25.0.10/24  
  3.查看主机名:desktop0.example.com

#################################################
利用真机,远程管理两台虚拟机
1.前提真机可以与两台虚拟机通信
[student@room9pc01 ~]$ ping 172.25.0.11

[student@room9pc01 ~]$ ping 172.25.0.10

2.真机上,ssh命令进行远程管理

    ssh   对方用户名@对方IP地址
[student@room9pc01 ~]$ ssh　root@172.25.0.11 

[student@room9pc01 ~]$ ssh　root@172.25.0.10

开启一个新的终端：ctrl + shift + t

   -X(大写):在远程管理时,开启对方的图形程序

[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ ssh -X root@172.25.0.11
[root@server0 ~]# firefox           #火狐浏览器

[root@server0 ~]# firewall-config   #防火墙图形配置工具


常见提示:dconf桌面服务报错,与远程管理无关
(process:30405): dconf-WARNING **: failed to commit changes to dconf: 无法连接：拒绝连接

###################################################
补充:为真机,设置永久的别名,修改系统级配置文件
   ~/.bashrc  #设置永久别名配置文件,每开一个终端会被执行一次

[student@room9pc01 ~]$ vim /home/student/.bashrc
# .bashrc
alias  gos='ssh  -X  root@172.25.0.11'
alias  god='ssh  -X  root@172.25.0.10'

新开一个终端验证:
[student@room9pc01 ~]$ gos
[student@room9pc01 ~]$ god

#################################################
权限和归属

基本权限

• 访问方式(权限)
– 读取:允许查看内容-read  r
– 写入:允许修改内容-write  w
– 可执行:允许运行和切换-execute  x

  对文本文件:
       r: cat less head tail 
       w: vim 保存   >   >>
       x: 书写Shell脚本或Python脚本

• 权限适用对象(归属)
– 所有者(属主):拥有此文件/目录的用户-user  u
– 所属组(属组):拥有此文件/目录的组-group    g
– 其他用户:除所有者、所属组以外的用户-other   o

     zhangsan       1.txt
         所有者的基本组成为该文件的所属组

####################################################
查看权限
• 使用 ls -l 命令
– ls -ld 文件或目录...

   以d开头:目录
   以-开头:文件
   以l开头:快捷方式

[root@server0 ~]# ls -ld /etc/
[root@server0 ~]# ls -l /etc/passwd

[root@server0 ~]# ls -l /etc/shadow
[root@server0 ~]# ls -ld /home/student
[root@server0 ~]# ls -ld /tmp
####################################################
设置基本权限
• 使用 chmod 命令
– chmod  归属关系+-=权限类别  文档...

   [-R]:递归设置权限

[root@server0 ~]# mkdir /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod g+w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod u-w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod o=--- /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod u=rwx,g=rx,o=rx /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod ugo=rwx /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# mkdir -p /opt/aa/bb/cc
[root@server0 ~]# ls -ld /opt/aa
[root@server0 ~]# ls -ld /opt/aa/bb/
[root@server0 ~]# ls -ld /opt/aa/bb/cc/

[root@server0 ~]# chmod -R o=--- /opt/aa
[root@server0 ~]# ls -ld /opt/aa

##################################################
Linux判定用户具备的权限                      匹配及停止
    1.判定用户对该文档的身份               所有者>所属组>其他人       
    2.查看相应身份 权限位的权限
  
Permission denied :权限不足

目录的 r 权限:能够 ls 浏览此目录内容
目录的 w 权限:能够执行 rm/mv/cp/mkdir/touch/等更改目录内容的操作
目录的 x 权限:能够 cd 切换到此目录


以root用户新建/nsddir目录，在此目录下新建readme.txt文件
并进一步完成下列操作
 1）使用户lisi能够在此目录下创建子目录     切换用户 su  -  lisi
     chmod o+w  /nsddir/
 2）使用户lisi不能够在此目录下创建子目录
     chmod o-w  /nsddir/
 3）使用户lisi能够修改readme.txt文件内容
     chmod o+w  /nsddir/readme.txt
 4）调整此目录的权限，使所有用户都不能cd进入此目录
     chmod u-x,g-x,o-x  /nsddir/
 5）为此目录及其下所有文档设置权限 rwxr-x---
     chmod -R  u=rwx,g=rx,o=---  /nsddir/
　　　-R：递归设置权限，目录下及目录下所有

##################################################
设置文档归属
• 使用 chown 命令
– chown [-R] 属主       文档...
– chown [-R] :属组      文档...
– chown [-R] 属主:属组   文档...

[root@server0 ~]# groupadd tedu
[root@server0 ~]# mkdir /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown lisi:tedu /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown zhangsan /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown :root  /nsd03
[root@server0 ~]# ls -ld /nsd03

################################################
利用root用户新建/nsd06目录，并进一步完成下列操作
1）将属主设为gelin01，属组设为tarena组              
[root@server0 /]# useradd gelin01
[root@server0 /]# useradd gelin02
[root@server0 /]# groupadd tarena
[root@server0 /]# chown gelin01:tarena  /nsd06
2）使用户gelin01对此目录具有rwx权限
      除属主与属组之外的人，对此目录无任何权限
[root@server0 /]# chmod o=--- /nsd06
3）使用户gelin02能进入、查看此目录内容
[root@server0 /]# gpasswd -a  gelin02  tarena
4）将gelin01加入tarena组, 将nsd06目录的权限设为rw-r-x---
      再测试gelin01用户能否进入此目录
[root@server0 /]# gpasswd -a  gelin01  tarena
[root@server0 /]# chmod u=rw,g=rx /nsd06
###################################################
让lisi用户可以读取/etc/shadow文件内容,您有几种办法  
   1.利用其他用户
      chmod  o+r  /etc/shadow
           
   2.利用所属组
      chown :lisi  /etc/shadow
      chmod  g+r   /etc/shadow

   3.利用所有者
      chown  lisi  /etc/shadow
      chmod  u+r   /etc/shadow
###################################################
附加权限(特殊权限)

Set GID
• 附加在属组的 x 位上
属组的权限标识会变为 s
适用于目录,Set GID可以使目录下新增的文档自动设置与父目录相同的属组
让父目录下,新增的子文档继承父目录的所属组身份

[root@server0 ~]# mkdir /nsd07
[root@server0 ~]# chown :tedu /nsd07   #修改所属组
[root@server0 ~]# ls -ld /nsd07

[root@server0 ~]# mkdir /nsd07/abc
[root@server0 ~]# ls -ld /nsd07/abc
[root@server0 ~]# chmod g+s /nsd07/    #设置Set GID权限
[root@server0 ~]# ls -ld /nsd07/

[root@server0 ~]# mkdir /nsd07/test
[root@server0 ~]# ls -l /nsd07/

[root@server0 ~]# touch /nsd07/1.txt
[root@server0 ~]# ls -l /nsd07/

###################################################

        /nsd09  rwx  r-x ---  存放打卡记录
         2019-5-6.txt
         2019-5-7.txt
         2019-5-8.txt
         2019-5-9.txt

        groupadd  caiwu

        chown  :caiwu  /nsd09
        chmod  g+s   /nsd09

##################################################
Set UID
• 附加在属主的 x 位上
属主的权限标识会变为 s
适用于可执行文件,Set UID可以让使用者具有文件属主的身份及部分权限

[root@server0 ~]# /usr/bin/mkdir /opt/haha   
[root@server0 ~]# ls /opt/
[root@server0 ~]# cp /usr/bin/mkdir /usr/bin/hahadir
[root@server0 ~]# /usr/bin/hahadir /opt/xixi
[root@server0 ~]# ls /opt/
[root@server0 ~]# chmod u+s /usr/bin/hahadir 
[root@server0 ~]# ls -l /usr/bin/hahadir
[root@server0 ~]# su - lisi
[lisi@server0 ~]$ /usr/bin/mkdir  test01
[lisi@server0 ~]$ /usr/bin/hahadir test02
[lisi@server0 ~]$ ls
test01  test02
[lisi@server0 ~]$ ls -l
[lisi@server0 ~]$ exit
###################################################

Sticky Bit
• 附加在其他人的 x 位上
其他人的权限标识会变为 t
适用于开放 w 权限的目录,可以阻止用户滥用 w 写入权限(禁止操作别人的文档)

[root@server0 ~]# mkdir /public
[root@server0 ~]# chmod ugo=rwx /public
[root@server0 ~]# ls -ld /public

[root@server0 ~]# chmod o+t /public/
[root@server0 ~]# ls -ld /public/

##########################################
Admin06                                 #
########################################
ACL权限(策略)

acl策略的作用
• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持


设置acl访问控制策略
• 使用 getfacl、setfacl 命令
– getfacl 文档...
– setfacl [-R] -m u:用户名:权限类别     文档...
– setfacl [-R] -m g:组名:权限类别       文档...
– setfacl [-R] -b      文档...                #删除所有ACL策略
– setfacl [-R] -x u:用户名    文档...     #删除指定ACL策略


让lisi用户可以读取/etc/shadow文件内容,您有几种办法  
   1.利用其他用户
      chmod  o+r   /etc/shadow
   2.利用所属组
      chown :lisi  /etc/shadow
      chmod  g+r   /etc/shadow
   3.利用所有者
      chown  lisi  /etc/shadow
      chmod  u+r   /etc/shadow
   4.利用ACL策略
      setfacl  -m u:lisi:r  /etc/shadow


[root@server0 ~]# mkdir /nsd01
[root@server0 ~]# chmod o=--- /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# su - student
[student@server0 ~]$ cd /nsd01
-bash: cd: /nsd01: Permission denied
[student@server0 ~]$ exit
logout
[root@server0 ~]# setfacl -m  u:student:rx  /nsd01
[root@server0 ~]# getfacl /nsd01   #查看ACL策略
[root@server0 ~]# su - student
[student@server0 ~]$ cd /nsd01
[student@server0 nsd01]$ pwd

#####################################################

[root@server0 ~]# mkdir /nsd02
[root@server0 ~]# setfacl -m u:student:rwx /nsd02
[root@server0 ~]# setfacl -m u:dc:rx /nsd02
[root@server0 ~]# setfacl -m u:lisi:rx /nsd02
[root@server0 ~]# setfacl -m u:zhangsan:rwx /nsd02

[root@server0 ~]# getfacl /nsd02
[root@server0 ~]# setfacl -x u:dc  /nsd02   #删除指定ACL
[root@server0 ~]# getfacl /nsd02

[root@server0 ~]# setfacl -b /nsd02  #删除所有ACL策略
[root@server0 ~]# getfacl /nsd02

###################################################
设置黑名单
[root@server0 ~]# mkdir /public            
[root@server0 ~]# chmod ugo=rwx /public
[root@server0 ~]# ls -ld /public

[root@server0 ~]# setfacl -m u:lisi:--- /public
[root@server0 ~]# getfacl /public

[root@server0 ~]# su - lisi
[lisi@server0 ~]$ cd /public/
-bash: cd: /public/: Permission denied
[lisi@server0 ~]$ ls /public/
ls: cannot open directory /public/: Permission denied
[lisi@server0 ~]$ exit

###################################################
软件包管理

一 零散软件管理
1.前提具备软件包

2.虚拟机classroom搭建Web服务器,共享RHEL7.0光盘所有内容

  Web服务:提供网页内容的服务

3.访问虚拟机classroom网页
   真机利用火狐浏览器:   classroom.example.com

classroom.example.com/content/rhel7.0/x86_64/dvd/

4.下载软件包到虚拟机server:
• 使用wget下载工具
– wget 软件包的URL网址
– wget 软件包的URL网址   -O  /目录路径/新文件名

   Packages目录中
   在火狐浏览器中,按键盘  Ctrl + f  进行当前页面搜索

[root@server0 ~]# wget   软件包的网络路径
[root@server0 ~]# wget  http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/vsftpd-3.0.2-9.el7.x86_64.rpm

[root@server0 ~]# ls 


使用rpm命令管理软件
• RPM Package Manager,RPM包管理器
– rpm -q   软件名...
– rpm -ivh 软件名-版本信息.rpm...
– rpm -e   软件名...

1 查询软件是否安装
[root@server0 ~]# rpm -q firefox
[root@server0 ~]# rpm -q zip

[root@server0 ~]# rpm -q hostname   
[root@server0 ~]# rpm -q vsftpd   #查询软件软件安装

[root@server0 ~]# rpm -q haha

2.安装软件包
[root@server0 ~]# rpm -q vsftpd  
未安装软件包 vsftpd 

]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

[root@server0 ~]# rpm -q vsftpd
 
[root@server0 ~]# rpm -e vsftpd    #卸载
[root@server0 ~]# rpm -q vsftpd    #查询是否卸载成功
未安装软件包 vsftpd 
[root@server0 ~]# 

补充内容:
[root@server0 ~]# rpm -ql vsftpd   #已安装软件的清单

了解:导入红帽签名信息
]# wget http://classroom.example.com/content/rhel7.0/x86_64/dvd/RPM-GPG-KEY-redhat-release

]# ls

]# rpm --import /root/RPM-GPG-KEY-redhat-release 

]# rpm -e vsftpd
]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

##################################################
常见报错信息:
]# rpm -ivh /root/bind-chroot-9.9.4-14.el7.x86_64.rpm 
错误：依赖检测失败：
	bind = 32:9.9.4-14.el7 被 bind-chroot-32:9.9.4-14.el7.x86_64 需要

#################################################
Yum软件包仓库:自动解决依赖关系安装软件

构建Yum服务

服务:自动解决依赖关系安装软件

服务端:  1.众多的软件包   2.仓库数据文件  3.构建FTP或Web服务
                   都在光盘内容里

           虚拟机classroom:构建Web服务,共享光盘所有内容


客户端: 虚拟机server 指定服务端位置
    书写配置文件: /etc/yum.repos.d/*.repo
    错误的文件会影响正确的配置文件
[root@server0 /]# rm -rf /etc/yum.repos.d/*
[root@server0 /]# vim  /etc/yum.repos.d/dvd.repo
 [rhel7]                #仓库标识
 name=rhel7.0           #仓库描述信息
 baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/             #指定服务端位置
 enabled=1              #是否启用本文件
 gpgcheck=0             #是否检测软件包的红帽签名

[root@server0 /]# yum repolist   #显示仓库基本信息

Yum仓库的使用:
[root@server0 /]# yum -y install httpd    
[root@server0 /]# yum -y install sssd
[root@server0 /]# yum -y install gcc
[root@server0 /]# yum -y install system-config-kickstart
[root@server0 /]# yum -y install tftp-server

卸载软件包:
[root@server0 /]# yum remove httpd
[root@server0 /]# yum remove gcc
[root@server0 /]# yum remove sssd

清空Yum缓存:
[root@server0 /]# yum repolist 
[root@server0 /]# yum clean all   #清空Yum缓存
[root@server0 /]# yum repolist 
#################################################
升级内核

1.下载新的内核
[root@server0 ~]# wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

[root@server0 ~]# ls

2.查看当前系统内核版本
[root@server0 ~]# uname -r
 3.10.0-123.el7.x86_64

3.安装新的内核软件包
]# rpm -ivh /root/kernel-3.10.0-123.1.2.el7.x86_64.rpm 

4.重启虚拟机server验证:
[root@server0 ~]# reboot 
Connection to 172.25.0.11 closed by remote host.
Connection to 172.25.0.11 closed.

[student@room9pc01 ~]$ gos
[root@server0 ~]# uname -r
3.10.0-123.1.2.el7.x86_64
[root@server0 ~]# 
####################################################
分区规划及使用

  扇区默认的大小512字节

•  识别硬盘 => 分区规划 => 格式化 => 挂载使用
     毛坯楼层 => 打隔断 => 装修  =>入驻

一  识别硬盘
[root@server0 ~]# lsblk               
NAME    SIZE  TYPE MOUNTPOINT
vda     10G   disk 
└─vda1   10G   part /
vdb      10G   disk 

[root@server0 ~]# ls /dev/vdb

关机添加一块新的硬盘60G硬盘
[root@server0 ~]# poweroff 
Connection to 172.25.0.11 closed by remote host.
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ gos
[root@server0 ~]# lsblk 
[root@server0 ~]# ls   /dev/vdc

二  分区规划 

     分区模式: 
     MBR主引导记录的分区模式
         – 最大支持容量为 2.2TB 的磁盘
         – 1~4个主分区,或者 3个主分区+1个扩展分区(n个逻辑分区)
         – 扩展分区不能格式化

• 修改硬盘的分区表
[root@server0 ~]# fdisk /dev/vdb
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
  p 查看分区表
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +1G
  d 删除分区
  w 保存并退出 

[root@server0 ~]# lsblk 
[root@server0 ~]# ls  /dev/vdb[1-2]

   /dev/sda5设备表示的含义:
                     第一块SCSI接口的硬盘,第5个分区
                     第一块SCSI接口的硬盘,第1个逻辑分区

三  格式化:赋予空间文件系统的过程               

     文件系统:空间存储数据的规则
  
    Windows: NTFS   FAT32

    Linux:  ext4(RHEL6)   xfs(RHEL7)

[root@server0 ~]# mkfs.ext4 /dev/vdb1  #格式化ext4文件系统
[root@server0 ~]# blkid /dev/vdb1      #查看分区文件系统

[root@server0 ~]# mkfs.xfs /dev/vdb2   #格式化xfs文件系统
[root@server0 ~]# blkid /dev/vdb2      #查看分区文件系统



四 挂载使用
[root@server0 ~]# mkdir /mypart1
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# df -h  #查看正在挂载的设备,使用情况

[root@server0 ~]# mkdir /mypart2
[root@server0 ~]# mount /dev/vdb2  /mypart2
[root@server0 ~]# df -h  #查看正在挂载的设备,使用情况

五  开机自动挂载

• 配置文件 /etc/fstab 的记录格式
   设备路径       挂载点        类型        参数         备份标记    检测顺序

[root@server0 ~]# vim  /etc/fstab  
 #命令模式 按 o可以另起新的一行进入 插入模式 
.......
/dev/vdb1  /mypart1  ext4   defaults  0 0
/dev/vdb2  /mypart2  xfs    defaults  0 0

[root@server0 ~]# umount /mypart1
[root@server0 ~]# umount /mypart2
[root@server0 ~]# df -h
[root@server0 ~]# mount -a
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载
[root@server0 ~]# df -h

六 综合分区
综合分区，/dev/vdb继续分区
最终有3个主分区，分别为2G、1G、1G
   创建扩展分区 --->  两个逻辑分区，分别为1G、1G
[root@server0 ~]# fdisk  /dev/vdb
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +1G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe   #刷新分区表
[root@server0 ~]# lsblk 

####################################################
总结：
1.识别硬盘　lsblk
2.分区规划    fdisk
3.刷新分区表　　partprobe
4.进行格式化　　mkfs.xfs  mkfs.ext4   blkid
5.挂载使用　mount  /etc/fstab开机自动挂载   mount -a  df -h

##########################################
Admin07                                 #
########################################
图形添加一块硬盘为80G
[root@server0 ~]# lsblk 
NAME   SIZE  TYPE  MOUNTPOINT
vda     10G   disk 
└─vda1   10G   part  /
vdb      10G   disk 
vdc      80G   disk 
[root@server0 ~]# ls  /dev/vdc

综合分区:
划分三个主分区10G,一个扩展分区,二个逻辑分区10G
[root@server0 ~]# fdisk  /dev/vdc
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
         连续划分三个主分区
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# lsblk 
[root@server0 ~]# ls /dev/vdc[1-6]

###################################################
LVM逻辑卷
     作用:1.整合分散的空间     2.空间可以扩大            

– 零散空闲存储 ---- 整合的虚拟磁盘 ---- 虚拟的分区

   将众多的物理卷(PV),组建成卷组(VG),再从卷组中划分逻辑卷(LV)

LVM管理工具集
	功能 			物理卷管理 	卷组管理 		逻辑卷管理
	Scan 扫描 	pvs		     vgs 		lvs
	Create 创建 	pvcreate 	vgcreate 	lvcreate
	Display 显示 	pvdisplay 	vgdisplay 	lvdisplay
	Remove 删除 	pvremove 	vgremove 	lvremove
	Extend 扩展 	/                       vgextend 	lvextend

###################################################
创建逻辑卷
1.创建卷组
   命令格式: vgcreate  卷组名    分区设备路径......

[root@server0 ~]# vgcreate systemvg /dev/vdc[1-2]
[root@server0 ~]# pvs     #查看物理卷基本信息
[root@server0 ~]# vgs     #查看卷组基本信息

2.创建逻辑卷
   命令格式: lvcreate -n 逻辑卷名  -L  大小    基于的卷组名
[root@server0 ~]# lvcreate -n mylv -L 16G systemvg 
[root@server0 ~]# vgs
[root@server0 ~]# lvs     #查看逻辑卷基本信息

3.使用逻辑卷
[root@server0 ~]# ls /dev/dm-0
[root@server0 ~]# ls /dev/systemvg/mylv 
[root@server0 ~]# ls -l /dev/systemvg/mylv

[root@server0 ~]# mkfs.xfs /dev/systemvg/mylv
[root@server0 ~]# blkid /dev/systemvg/mylv
[root@server0 ~]# vim /etc/fstab 
 /dev/systemvg/mylv  /nsd  xfs  defaults  0 0

[root@server0 ~]# mkdir /nsd
[root@server0 ~]# mount -a
[root@server0 ~]# df -h
#################################################
逻辑卷扩大

一  卷组有足够的剩余空间                      
1.空间的扩展
[root@server0 ~]# lvs
[root@server0 ~]# vgs 
[root@server0 ~]# lvextend -L 18G /dev/systemvg/mylv 
[root@server0 ~]# lvs  
                                 
2.文件系统的扩展
   扩展xfs文件系统命令: xfs_growfs 
   扩展ext4文件系统命令: resize2fs 

[root@server0 ~]# df -h
[root@server0 ~]# xfs_growfs /dev/systemvg/mylv 
[root@server0 ~]# df -h

二 卷组没有足够的剩余空间
1.先扩展卷组的空间
[root@server0 ~]# vgextend systemvg /dev/vdb
[root@server0 ~]# vgs
2.逻辑卷空间的扩展
[root@server0 ~]# lvs
[root@server0 ~]# vgs 
[root@server0 ~]# lvextend -L 25G /dev/systemvg/mylv 
[root@server0 ~]# lvs  
                                 
2.逻辑卷文件系统的扩展
[root@server0 ~]# df -h
[root@server0 ~]# xfs_growfs /dev/systemvg/mylv 
[root@server0 ~]# df -h

###################################################
补充: 逻辑卷也支持缩减
     ext4文件系统支持缩减
     xfs文件系统不支持缩减
##################################################
卷组划分空间的单位   PE

[root@server0 ~]# vgdisplay systemvg #显示卷组详细信息

     PE Size               4.00 MiB


 请划分一个大小为250M的逻辑卷
[root@server0 ~]# vgchange -s 1M systemvg   #修改PE大小
[root@server0 ~]# vgdisplay systemvg      #查看详细信息
[root@server0 ~]# lvcreate -n lvtest -L 250M systemvg 
[root@server0 ~]# lvs

 请划分一个为800个PE大小的逻辑卷   -l:指定PE的个数
[root@server0 ~]# lvcreate -n lvnsd -l 800 systemvg
[root@server0 ~]# lvs
###################################################
逻辑卷的删除
  删除卷组前提:基于该卷组创建的,所有逻辑卷都要删除

[root@server0 ~]# lvremove /dev/systemvg/lvnsd 
Do you really want to remove active logical volume lvnsd? [y/n]: y
  Logical volume "lvnsd" successfully removed
[root@server0 ~]# 

[root@server0 ~]# lvremove /dev/systemvg/lvtest 
Do you really want to remove active logical volume lvtest? [y/n]: y
  Logical volume "lvtest" successfully removed


[root@server0 ~]# lvremove /dev/systemvg/mylv 
  Logical volume systemvg/mylv contains a filesystem in use.
[root@server0 ~]# umount /nsd/
[root@server0 ~]# lvremove /dev/systemvg/mylv 
Do you really want to remove active logical volume mylv? [y/n]: y
  Logical volume "mylv" successfully removed
[root@server0 ~]# lvs
[root@server0 ~]# vgs
##################################################
find高级使用

– find [目录] [条件1] [-a|-o] [条件2] ...

– 常用条件表示:                                     
	-type 类型(f、d、l)
	-name "文档名称"
	-size +|-文件大小(k、M、G)
	-user 用户名
	-mtime 根据文件修改时间

###############################################
	-type 类型(f文本文件、d目录、l快捷方式)
[root@server0 /]# find /boot  -type l
[root@server0 /]# ls -l /boot/grub/menu.lst

[root@server0 /]# find /boot  -type d
[root@server0 /]# find /boot  -type f

[root@server0 /]# find /root  -type d
[root@server0 /]# find /root  -type f

	-name '文档名称'
[root@server0 /]# find /etc/  -name  '*tab'
[root@server0 /]# find /etc/  -name  'passwd'
[root@server0 /]# find /etc/  -name  'passwd*'

[root@server0 /]# find /etc/  -name  '*.conf'

[root@server0 /]# find /boot  -name  'vm*'

[root@server0 /]# mkdir /root/nsd01
[root@server0 /]# mkdir /root/nsd02
[root@server0 /]# touch /root/nsd03.txt

[root@server0 /]# find  /root/  -name  'nsd*'
[root@server0 /]# find  /root/  -name  'nsd*'  -type f
[root@server0 /]# find  /root/  -name  'nsd*'  -type d

两个条件满足其一即可
[root@server0 /]# find /root/ -name 'nsd*' -o -type d 


	-size +|-文件大小(k、M、G)

[root@server0 /]# find /boot/ -size +10M
[root@server0 /]# ls -lh /boot/initramfs-*

[root@server0 /]# find /boot/ -size -10M 

	-mtime 根据文件修改时间(都是过去时间)
                    +10:十天之前
                    -10:最近十天之内

[root@server0 /]# find /var/   -mtime +90
[root@server0 /]# find /var/   -mtime +1000
[root@server0 /]# find /root/   -mtime -2

	-user 用户名

[root@server0 /]# find  /home  -user student
[root@server0 /]# ls -l  /home


[root@server0 /]# find  /  -user student
[root@server0 /]# ls -l /var/spool/student


#################################################

find扩展使用
• 使用find命令的 -exec 操作
– find .. .. -exec 处理命令 {} \;
– 优势:以 {} 代替每一个结果,逐个处理,遇 \; 结束

]# find /boot/ -size +10M
]# find /boot/ -size +10M  -exec  cp  {}  /opt/  \; 
]# ls /opt/

]# find / -user student  -type f  -exec cp {} /opt  \;
]# ls -A /opt/

]# find /boot/ -name 'vm*'  
]# find /boot/ -name 'vm*'  -exec  cp  {}  /opt/  \; 
]# ls -A /opt/

##################################################
NTP时间同步

[root@server0 /]# date    #查看系统时间 
[root@server0 /]# date -s '2000-10-1  12:10:08'

[root@server0 /]# date
[root@server0 /]# date -s  '年-月-日    时:分:秒'   #修改时间格式


NTP网络时间协议
• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通

NTP时间服务器:虚拟机classroom

NTP客户机:虚拟机server
1.安装chrony软件包,与时间服务器沟通软件
[root@server0 /]# yum -y install chrony
[root@server0 /]# rpm -q chrony

[root@server0 /]# rpm  -ql chrony
/etc/NetworkManager/dispatcher.d/20-chrony
/etc/chrony.conf

2.修改配置/etc/chrony.conf,指定时间服务器位置
[root@server0 /]# vim  /etc/chrony.conf   
 以#开头的为注释行

 #server 0.rhel.pool.ntp.org iburst
 #server 1.rhel.pool.ntp.org iburst
 #server 2.rhel.pool.ntp.org iburst
 server classroom.example.com  iburst   #指定服务端位置

3.重启服务(程序)
[root@server0 /]# systemctl  restart chronyd 
[root@server0 /]# systemctl  enable chronyd   #开机自启动

 daemon
  英 [ˈdiːmən] 美 [ˈdiːmən]
  (古希腊神话中的)半神半人精灵
  守护进程

4.验证:
[root@server0 /]# date -s '2000-1-1  1:1:1'
2000年 01月 01日 星期六 01:01:01 CST
[root@server0 /]# systemctl restart chronyd
[root@server0 /]# date
2000年 01月 01日 星期六 01:01:58 CST
[root@server0 /]# date
2019年 05月 09日 星期四 16:19:00 CST

###################################################
grep补充
	^$:匹配空行

[root@server0 /]# grep ^root /etc/passwd
[root@server0 /]# grep bash$  /etc/passwd

 显示/etc/login.defs文件有效信息(去除注释  去除空行)
]# grep -v ^# /etc/login.defs
]# grep -v ^# /etc/login.defs | grep   -v ^$
]# grep -v ^# /etc/login.defs | grep   -v ^$  >  /opt/1.txt

################################################
修改用户家目录                                                    
[root@server0 /]# useradd tom
[root@server0 /]# id tom
[root@server0 /]# grep tom /etc/passwd

[root@server0 /]# usermod -d  /opt/abc  tom
[root@server0 /]# grep tom /etc/passwd

[root@server0 /]# grep tom /etc/passwd
[root@server0 /]# ls /opt/abc    #默认没有创建该用户的家目录

[root@server0 /]# cp -r /home/tom  /opt/abc
[root@server0 /]# chown -R tom:tom /opt/abc
[root@server0 /]# su - tom

[tom@server0 ~]$ exit
###################################################
使用LDAP认证,实现网络用户认证,达到用户的集中管理
  
　　RHCSA　红帽认证管理员  
　　RHCE　红帽认证工程师
　　RHCA　红帽认证架构师

     网络用户:用户信息会放在网络中LDAP服务器
     本地用户:用户信息会放在/etc/passwd

LDAP服务器:虚拟机classroom

客户端:虚拟机server
1.安装sssd软件,与LDAP服务器沟通
[root@server0 /]# yum -y install sssd
[root@server0 /]# rpm -q sssd

2.安装authconfig-gtk图形的工具,进行配置客户端sssd软件
[root@server0 /]# yum -y install authconfig-gtk
[root@server0 /]# authconfig-gtk

完全合格的主机名  www.baidu.com　　　www.qq.com    
               classroom.example.com

     选择LDAP
      dc=example,dc=com             #指定服务端域名
      classroom.example.com         #指定服务端主机名
     勾选TLS加密
      使用证书加密:
     http://classroom.example.com/pub/example-ca.crt

     选择LDAP密码 

3.重起服务
[root@server0 ~]# systemctl  restart  sssd   #重起服务
[root@server0 ~]# systemctl  enable  sssd    #设置开机自启动
[root@server0 ~]# grep ldapuser0 /etc/passwd
[root@server0 ~]# id ldapuser0     #验证LDAP用户信息
          
###################################################      
家目录漫游

    在LDAP服务器搭建共享,共享所有普通用户的家目录

  LDAP服务器:虚拟机classroom

    虚拟机classroom已经完成共享所有操作

 虚拟机server:访问共享数据
[root@server0 ~]# mkdir /haha
[root@server0 ~]# ls /haha
[root@server0 ~]# showmount -e classroom.example.com
Export list for classroom.example.com:
/home/guests 172.25.0.0/255.255.0.0

[root@server0 ~]# mount classroom.example.com:/home/guests  /haha
[root@server0 ~]# df -h

[root@server0 ~]# mkdir /home/guests
[root@server0 ~]# mount classroom.example.com:/home/guests/   /home/guests
[root@server0 ~]# ls /home/guests

[root@server0 ~]# su - ldapuser0
上一次登录：三 4月 10 19:21:04 CST 2019pts/0 上
[ldapuser0@server0 ~]$ 

##########################################
enginner01                              #
########################################
什么是Shell脚本
• 提前设计可执行语句,用来完成特定任务的文件
– 解释型程序
– 顺序、批量执行

案例1:Shell脚本的编写及测试
1. 编写一个面世问候 /root/helloworld.sh 脚本
– 显示出一段话  Hello World

[root@server0 ~]# vim /root/hello.sh
echo Hello World
[root@server0 ~]# chmod +x /root/hello.sh  #赋予执行权限

[root@server0 ~]# /root/hello.sh    #绝对路径运行


规范Shell脚本的一般组成
• #! 环境声明,以下代码由那个程序进行解释
• # 注释文本
• 可执行代码


1)输出当前红帽系统的版本信息                
2)输出当前使用的内核版本
3)输出当前系统的主机名
[root@server0 ~]# vim /root/hello.sh 
#!/bin/bash
echo hello world
cat  /etc/redhat-release 
uname -r
hostname
ifconfig | head -2
[root@server0 ~]# /root/hello.sh 

#################################################
简单脚本技巧

重定向输出
     >:只收集前面命令的正确输出信息
     2>:只收集前面命令的错误输出信息
     &>:收集前面命令的正确与错误信息

[root@server0 ~]# cat /etc/redhat-release 
[root@server0 ~]# cat /xixi

[root@server0 ~]# cat /etc/redhat-release /xixi

]# cat /etc/redhat-release /xixi  >  /opt/1.txt
]# cat /opt/1.txt 

]# cat /etc/redhat-release /xixi  2>   /opt/2.txt
]# cat /opt/2.txt 

]# cat /etc/redhat-release /xixi  &>   /opt/3.txt
]# cat /opt/3.txt 

####################################################
案例:书写一个创建用户设置密码的脚本
      /dev/null:黑洞设备

[root@server0 ~]# vim  /root/user.sh
#!/bin/bash
useradd nsd04 &> /dev/null
echo 用户nsd04创建成功
echo 123 | passwd --stdin  nsd04 &> /dev/null
echo 用户nsd04密码设置成功
[root@server0 ~]# chmod +x   /root/user.sh

[root@server0 ~]# /root/user.sh


 为了让脚本,适应多变需求,所以使用变量

 变量:会变化的量     类似容器
        以不变的名称,存储可以变化的值               

 定义变量:
      变量名=存储的值

  使用变量储存的值:     $变量名

[root@server0 ~]# vim /root/user.sh
#!/bin/bash
a=dc
useradd $a  &> /dev/null
echo 用户$a创建成功
echo 123 | passwd --stdin  $a  &> /dev/null
echo 用户$a密码设置成功


  提高用户体验度,产生交互
   read
            1.直接产生交互,等待用户输入
            2.记录用户在键盘上的输入
            3.将记录的内容,赋值给一个变量储存
   -p  '屏幕提示信息'

[root@server0 ~]# vim  /root/user.sh
#!/bin/bash
read -p '请您输入要创建的用户名:'   a
read -p '请您输入要设置的密码:'   b
useradd $a &> /dev/null
echo 用户$a创建成功
echo $b  | passwd --stdin  $a &> /dev/null
echo 用户$a密码设置成功

[root@server0 ~]# 


什么是变量
• 以不变的名称存放的可能会变化的值
– 变量名=变量值
– 方便以固定名称重复使用某个值
– 提高对任务需求、运行环境变化的适应能力

定义/赋值变量
• 设置变量时的注意事项
– 等号两边不要有空格
– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符
– 若指定的变量名已存在,相当于为此变量重新赋值


  以下有效变量名为: B
  A.2008file   B.tun_01  C a-b   D a_ccd_9-abc

查看/引用变量
• 基本格式
– 引用变量值:$变量名
– 查看变量值:echo $变量名、echo ${变量名}

[root@server0 ~]# a=rhel
[root@server0 ~]# echo $a
rhel
[root@server0 ~]# echo $a7

[root@server0 ~]# echo ${a}7
rhel7

################################################
  单引号' ':取消所有特殊字符的意义,原样输出
[root@server0 ~]# echo '********'
********
[root@server0 ~]# echo '| ? * {} [] > '
| ? * {} [] > 
[root@server0 ~]# 

  反撇号 ` `  或  $(  ) 
       :将命令的输出,直接参与另一条命令的运行,作为另一条命令的参数
[root@server0 ~]# mkdir /opt/nsd`date +%F`
[root@server0 ~]# ls /opt/
[root@server0 ~]# mkdir /opt/`hostname`-`date  +%F`
[root@server0 ~]# ls /opt/

[root@server0 ~]# mkdir /opt/abc-$(date  +%F)
[root@server0 ~]# ls /opt/
###################################################

环境变量
    变量名为大写字母,由系统定义并且赋值完成

   USER=当前登录的用户名
[root@server0 ~]# echo $USER
root
[root@server0 ~]# su - student
[student@server0 ~]$ echo $USER
student
[student@server0 ~]$ exit
logout
[root@server0 ~]# su - nsd01
[nsd01@server0 ~]$ echo $USER
nsd01
[nsd01@server0 ~]$ 

#################################################

位置变量
• 由系统定义并且赋值完成
• 在执行脚本时提供的命令行参数
– 表示为 $n,n为序号
– $1、$2、.. .. ${10}、${11}、.. ..

[root@server0 ~]# vim  /root/user.sh 
#!/bin/bash
#read  -p  '请您输入要创建的用户名:'    a
#read  -p  '请您输入要设置的密码:'   b
useradd $1 &> /dev/null
echo 用户$1创建成功
echo  123  | passwd --stdin  $1 &> /dev/null
echo 用户$1密码设置成功
[root@server0 ~]#  /root/user.sh  natasha

[root@server0 ~]# vim  /root/1.sh
#!/bin/bash
cat -n  $1  |  head -$2
echo 您输入的文件为$1
echo 显示文件内容的头$2行
[root@server0 ~]# /root/1.sh  /etc/passwd  3
####################################################

预定义变量
• 由系统定义并且赋值完成                                    
  $#  已加载的位置变量的个数
  $?  程序退出后的状态值,0表示正常,其他值异常

[root@server0 ~]# vim /root/2.sh
#!/bin/bash
echo $1
echo $2
echo $3
echo $#
[root@server0 ~]# chmod +x /root/2.sh
[root@server0 ~]# /root/2.sh  haha xixi hehe lele

###################################################
条件测试

   [ 测试表达式 ]  每一部分都要有空格


常用的测试选项
• 检查文件状态
 -e:文档存在为真
 -d:文档存在,且必须为目录才为真
 -f:文档存在,且必须为文件才为真
[root@server0 ~]# [ -e /etc ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ -e /xixi ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -d /etc/passwd ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -f /etc/passwd ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# 

• 比较整数大小
  -gt:大于
  -ge:大于等于
  -eq:等于
  -ne:不等于
  -lt:小于
  -le:小于等于
[root@server0 ~]# [ 1 -eq 2 ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ 1 -eq 1 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ 10 -gt 9 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ 9 -ge 9 ]
[root@server0 ~]# echo $?

• 字符串比对
    ==:一致为真
    !=:不一致为真
[root@server0 ~]# [ student == dc ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ student == root ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ student != root ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ $USER == root ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# 
##################################################
if双分支处理

	if  [条件测试];then
	  命令序列xx
	else
	  命令序列yy
	fi

[root@server0 ~]# vim  /root/if01.sh
#!/bin/bash
if  [  $1  -eq  1  ];then
  echo hello
else
  echo hi
fi
[root@server0 ~]# /root/if01.sh 1
[root@server0 ~]# /root/if01.sh 2


案例:利用read获取,用户所输入的用户名
  进行判断,如果用户名当前系统已存在,则输出 用户已存在    
  进行判断,如果用户名当前系统不存在,则输出 用户不存在
[root@server0 ~]# vim  /root/if02.sh      
#!/bin/bash
read  -p  '请输入您要测试的用户名:'    a
id $a  &> /dev/null
if [  $?  -eq  0  ];then
  echo  $a用户已存在
else
  echo  $a用户不存在
fi
[root@server0 ~]# 


案例:利用read获取,用户所输入的IP地址
  进行判断,如果当前系统可以与该IP地址通信,则输出 可以ping通 
  进行判断,如果当前系统不可以与该IP地址通信,则输出 不可以ping通 
[root@server0 ~]# vim /root/if03.sh 
 #!/bin/bash
 read  -p  '请输入您要测试的IP地址:'    ip
 ping -c 2 $ip &> /dev/null
 if [ $? -eq 0 ];then
  echo $ip可以通信
 else
  echo $ip不可以通信
 fi

 ##################################################
if多分支处理

	if [条件测试1];then
	  命令序列xx
	elif [条件测试2];then
	  命令序列yy
	elif [条件测试3];then
	  命令序列aa
       ..........
	else
	  命令序列zz
	fi

案例:利用read获取,用户所输入的成绩 
 进行判断
    如果大于等于90,则输出  优秀
    如果大于等于80,则输出  良好
    如果大于等于70,则输出  一般
    如果大于等于60,则输出  合格
    以上条件均不满足,则输出 再牛的肖邦,也弹不出哥的悲伤

[root@server0 ~]# vim  /root/if04.sh
 #!/bin/bash
 read  -p  '请输入您的成绩:'     num
 if  [ $num  -ge  90 ];then
   echo  优秀
 elif  [ $num -ge  80 ];then
   echo  良好
 elif  [ $num -ge  70 ];then
   echo  一般
 elif  [ $num -ge  60 ];then
   echo  合格
 else
   echo  '再牛的肖邦,也弹不出哥的悲伤!'
 fi

####################################################
列表式循环,反复执行类似的操作

for循环处理
• 遍历/列表式循环
– 根据变量的不同取值,重复执行xx处理

	for 变量名  in 值列表
	do
	   命令序列
	done

    for 献血车  in  zhangsan  lisi  wangwu
	do
	    抽血
	done

[root@server0 ~]# vim  /root/for01.sh     
#!/bin/bash
for a  in  zhangsan lisi  wangwu  natasha  harry jack
do
  useradd $a &> /dev/null
  echo $a创建成功
done
[root@server0 ~]# 


列表值可以不参与循环执行的操作

造数工具: {起始..结束}    

   {1..20}:制造1到20之间连续的数字

[root@server0 ~]# vim /root/for01.sh 
#!/bin/bash
for a  in  {1..20}
do
  echo Hello World
done

###################################################
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: 
  /root/foo.sh  redhat|fedora

[root@server0 ~]# vim /root/foo.sh 
#!/bin/bash
if [ $# -eq 0 ];then     #判断用户是否输入参数
 echo '/root/foo.sh  redhat|fedora' >&2  #将正确输出变成错误输出
 exit 38   #脚本退出返回值
elif [ $1 == redhat ];then   #判断参数是否是redhat
 echo fedora
elif [ $1 == fedora ];then   #判断参数是否是fedora
 echo redhat
else
 echo '/root/foo.sh  redhat|fedora' >&2   #将正确输出变成错误输出
 exit 48  #脚本退出返回值
fi

##########################################
Engineer02                              #
########################################
案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示
 Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
 http://classroom.example.com/pub/materials/userlist

[root@server0 ~]# vim /root/batchusers
 #!/bin/bash
 if  [ $# -eq 0 ];then                #判断用户是否输入参数
  echo 'Usage: /root/batchusers' >&2
  exit 2
 elif [ -f $1 ];then　　　　　　　　＃判断用户输入的文件是否存在
  for a  in $(cat $1)
  do
   useradd -s /bin/false $a  &> /dev/null
   echo $a创建成功
  done
 else
  echo 'Input file not found' >&2
  exit 3
 fi
[root@server0 ~]# /root/batchusers  /root/userlist

###########################################################
系统安全保护

SELinux安全机制

• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系
– 集成到Linux内核(2.6及以上)中运行
– RHEL7基于SELinux体系针对用户、进程、目录和文件
提供了预设的保护策略,以及管理工具

• SELinux的运行模式
– enforcing(强制)、permissive(宽松)             
– disabled(彻底禁用)

  所有状态变成disabled(彻底禁用),都要经历重启系统

• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件

虚拟机server
[root@server0 ~]# getenforce    #查看SELinux当前系统状态
Enforcing
[root@server0 ~]# setenforce 0  #修改SELinux状态,为宽松模式
[root@server0 ~]# getenforce 
Permissive  
[root@server0 ~]# vim /etc/selinux/config#SELinux状态永久配置文件
SELINUX=permissive

虚拟机desktop
[root@desktop0 ~]# getenforce 
Enforcing
[root@desktop0 ~]# setenforce 0
[root@desktop0 ~]# getenforce 
Permissive
[root@desktop0 ~]# vim /etc/selinux/config 
SELINUX=permissive
##########################################################
用户个性化配置文件
• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效

全局环境配置
• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

虚拟机server0
[root@server0 ~]# vim /home/student/.bashrc 
alias hello='echo  hello'
[root@server0 ~]# vim /root/.bashrc 
alias hi='echo  hi'
[root@server0 ~]# vim /etc/bashrc 
alias dc='echo  dc'

#######################################################
搭建基本Web服务,提供一个网页内容
  http协议:超文本传输协议,专用于传输页面内容

服务端:虚拟机server
1.安装httpd软件包
[root@server0 ~]# yum -y install httpd
2.重启httpd服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd
ln -s '/usr/lib/systemd/system/httpd.service' '/etc/systemd/system/multi-user.target.wants/httpd.service'

3.本机测试
[root@server0 ~]# firefox 172.25.0.11         

4.书写自己的页面
   默认存放文件文件路径:/var/www/html/
   默认网页文件名称:index.html
[root@server0 ~]# cat  /var/www/html/index.html
<marquee><font  color=red><h1>NSD1904hahaxixi
  滚动            字体颜色            标题字体
[root@server0 ~]# 

#######################################################
搭建基本的FTP服务

  FTP:文件传输协议

默认FTP服务共享位置:/var/ftp/

虚拟机server
1.安装vsftpd软件
[root@server0 ~]# yum -y install vsftpd
2.重启vsftpd服务
[root@server0 ~]# systemctl restart  vsftpd
[root@server0 ~]# systemctl enable  vsftpd
3.本机验证
[root@server0 ~]# firefox ftp://172.25.0.11

##########################################################
防火墙策略管理
   
    作用:隔离,进行入站过滤

 硬件防火墙
 软件防火墙

 firewalld服务基础
Linux的防火墙体系
• 系统服务:firewalld
• 管理工具:firewall-cmd、firewall-config

预设安全区域
• 根据所在的网络场所区分,预设保护规则集
 – public:仅允许访问本机的sshd dhcp  ping 
 – trusted:允许任何访问
 – block:拒绝任何来访请求(明确拒绝回应)
 – drop:丢弃任何来访的数据包(直接丢弃不给回应,节省服务器资源)

 数据包: 源IP地址  目标IP地址   数据

防火墙的判定规则
1.查看请求数据包,中客户端来源IP地址,查看自己所有区域规则,如果某一个区域有该源IP地址的规则,则进入该区域

2.进入默认区域public

#######################################################
防火墙默认区域修改
虚拟机server
]# firewall-cmd --get-default-zone  #查看默认区域
虚拟机desktop
]# ping  172.25.0.11   #可以通信

虚拟机server
]# firewall-cmd --set-default-zone=block   #修改默认区域为block
]# firewall-cmd --get-default-zone    #查看默认区域
虚拟机desktop
]# ping  172.25.0.11  #不可以通信,有回应

虚拟机server
]# firewall-cmd --set-default-zone=drop  #修改默认区域为drop
]# firewall-cmd --get-default-zone   #查看默认区域
虚拟机desktop
]# ping  172.25.0.11  #不可以通信,没有回应
###########################################################
常见的互联网协议:
           http:超文本传输协议    默认端口:80 
           FTP:文本传输协议   默认端口:21
           https:安全的超文本传输协议   默认端口:443
           DNS:域名解析协议      默认端口:53
           telnet:远程管理协议     默认端口:23
           tftp:简单的文本传输协议   默认端口:69
           smtp:发邮件协议    默认端口:25
           pop3:收邮件协议    默认端口:110
           snmp:简单的网络管理协议   默认端口:161 


在默认区域添加协议:
虚拟机server:
]# firewall-cmd --set-default-zone=public  #修改默认区域为public
]# firewall-cmd --get-default-zone 
]# firewall-cmd --zone=public  --list-all  #查看区域详细规则
虚拟机desktop
]# firefox 172.25.0.11        #失败
]# firefox ftp://172.25.0.11  #失败

虚拟机server:
]# firewall-cmd --zone=public  --list-all
]# firewall-cmd --zone=public  --add-service=http #添加允许的协议
]# firewall-cmd --zone=public  --add-service=ftp #添加允许的协议
]# firewall-cmd --zone=public  --list-all
虚拟机desktop
]# firefox 172.25.0.11        #成功
]# firefox ftp://172.25.0.11  #成功

##########################################################
防火墙永久策略                                                    

– 永久(permanent)
]# firewall-cmd --reload   #重新加载防火墙所有配置

]# firewall-cmd --permanent --zone=public  --add-service=http
]# firewall-cmd --permanent --zone=public  --add-service=ftp
]# firewall-cmd --zone=public --list-all 

]# firewall-cmd --reload  #重新加载防火墙所有配置

]# firewall-cmd --zone=public --list-all 

#########################################################
单独拒绝虚拟机desktop的访问

]# firewall-cmd --zone=block --add-source=172.25.0.10
]# firewall-cmd --zone=block --list-all 


#########################################################

 端口:编号    标识协议或服务 可以具备多个
           由root指定

数据包: 源IP地址   目标IP地址   端口号    数据

实现本机的端口映射
• 本地应用的端口重定向(端口1 --> 端口2)                            
– 从客户机访问 端口1 的请求,自动映射到本机 端口2
– 比如,访问以下两个地址可以看到相同的页面:
  http://172.25.0.11:5423 --->  http://172.25.0.11:80

虚拟机server
]# firewall-cmd --permanent --zone=public  --add-forward-port=port=5423:proto=tcp:toport=80

]# firewall-cmd --reload 

]# firewall-cmd --zone=public --list-all

虚拟机desktop
]# firefox  172.25.0.11:5423 

##########################################
Engineer03                              #
########################################
案例练习,准备:
            rht-vmctl  reset  classroom
            rht-vmctl  reset  server
	        rht-vmctl  reset  desktop
######################################################


案例1:在在 server0、desktop0 上操作
– 将防火墙默认区域设置为trusted

案例2:指定yum软件源
为 server0 指定可用的 yum 软件源
– YUM软件库的地址为 http://classroom.example.com/content/rhel7.0/x86_64/dvd
– 将此配置为虚拟机 server0 的默认软件仓库
– 确认可用的仓库列表
– 利用yum仓库安装system-config-kickstart 



案例3:tar制作/释放归档压缩包（zcf、ztf、zxf、jcf、jtf、jxf、cf、tf）
  首先创建/root/boothome/与/root/usrsbin/目录
    1）备份/boot、/home这两个文件夹，保存为boothome.tar.gz文件
    2）查看boothome.tar.gz文件内包含哪些内容 
    3）将boothome.tar.gz释放到文件夹/root/boothome/下
    4）备份/usr/sbin目录，保存为usrsbin.tar.bz2文件
    5）查看usrsbin.tar.bz2文件内包含哪些内容
    6）将usrsbin.tar.bz2释放到/root/usrsbin/文件夹下


案例4:在server上操作，搭建mariadb数据库系统
1. 在 server0 上安装 MariaDB 数据库系统
1)安装 mariadb-server软件包
2)启动 mariadb 服务


案例5:在server上操作，配置一个数据库
– 为mariadb数据库root设置登陆密码为 haxi
– 新建一个数据库名为 nsd
– 除了 root 用户,此数据库只能被用户 lisi 查询,此用户的密码为 123(用户的授权)
– 数据库 nsd 中应该包含来自数据库复制的内容,(数据库导入数据)
数据库文件的 URL为:http://classroom/pub/materials/users.sql



案例6:在server上操作，使用数据库查询

1)查询base表所有内容
2)查询location表所有内容
3)查询base表的结构
4)查询location表的结构
5)查询base表内容,只显示name字段
6)查询mysql表内容,只显示user,host,password字段
7)密码是 solicitous 的人的名字?
8)有多少人的姓名是 Barbara 同时居住在 Sunnyvale?
9)在base表中追加记录  id为6，name为Barbara，password为900
10)在location表中追加记录  id为6，city为Sunnyvale
11)再次查询有多少人的姓名是 Barbara 同时居住在 Sunnyvale?




案例7:虚拟机 server0操作， /dev/vdb 上按以下要求建立分区：

采用默认的 msdos 分区模式 
– 第1个分区 /dev/vdb1 的大小为 3G
– 第2个分区 /dev/vdb2 的大小为 200M
– 第3个分区 /dev/vdb3 的大小为 100M
– 第4个分区 /dev/vdb4为扩展分区
– 在划分三个分区逻辑分区/dev/vdb[5-6]，
– 分区大小依次为500M、2000M


案例8：发布iSCSI网络磁盘

 1）配置 server0 提供 iSCSI 服务，要求如下：
 2）磁盘名为iqn.2016-02.com.example:server0
 3）服务端口为 3260
 4）使用 iscsi_store（后端存储的名称） 作其后端卷，其大小为 3GiB
 5）此磁盘服务只能被 desktop0.example.com 访问，在Server0上配置客户端ACL为iqn.2016-02.com.example:desktop0
 6）配置虚拟机desktop0 使用 虚拟机server0 提供 iSCSI 服务

##########################################
Engineer04                              #
########################################
配置NFS共享
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)、RPC(TCP/UDP 111)
• 所需软件包:nfs-utils
• 系统服务:nfs-server

一  环境设置
虚拟机server
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@server0 ~]# firewall-cmd --get-default-zone
虚拟机desktop
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --get-default-zone

二  虚拟机server构建NFS共享

1.安装nfs-utils软件包
[root@server0 ~]# rpm -q nfs-utils
nfs-utils-1.3.0-0.el7.x86_64
[root@server0 ~]# 
2.修改配置文件
[root@server0 ~]# mkdir /nsd01              #创建共享目录
[root@server0 ~]# echo haha > /nsd01/a.txt  #建立测试文件
[root@server0 ~]# ls /nsd01

[root@server0 ~]# vim /etc/exports
 文件夹路径    客户机地址(权限)  客户机地址(权限) .. ..
/nsd01   *(ro)      #将/nsd01目录共享给所有客户端,可以只读方式访问

[root@server0 ~]# systemctl restart nfs-server  #重启服务
[root@server0 ~]# systemctl enable nfs-server  #设置开机自启动

虚拟机desktop                             
[root@desktop0 ~]# mkdir /mnt/test
[root@desktop0 ~]# ls /mnt/test
[root@desktop0 ~]# showmount -e 172.25.0.11  #显示服务端共享路径
[root@desktop0 ~]# mount 172.25.0.11:/nsd01  /mnt/test/
[root@desktop0 ~]# df -h

开机自动挂载
   _netdev:声明网络设备,Linux先部署网络所有参数,在进行挂载该设备

[root@desktop0 ~]# vim /etc/fstab  
172.25.0.11:/nsd01    /mnt/test   nfs   defaults,_netdev  0 0 

[root@desktop0 ~]# umount /mnt/test/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
#########################################################
HTTP服务基础

Web通信基本概念
• 基于 B/S (Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页
• Hyper Text Transfer Protocol(http),超文本传输协议
• Hyper Text Markup Language(html),超文本标记语言


提供Web服务的软件
  httpd(Apache)、nginx、tomcat


• 软件包:httpd
• 系统服务:httpd
• 提供的默认配置
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)

虚拟机server:构建基本的Web服务
1.安装httpd
2.重启httpd服务
]# systemctl restart httpd
3.设置httpd服务开机自启
4.书写一个网站内容
]# echo '<h1>NSD1904 Web1' > /var/www/html/index.html
]# cat /var/www/html/index.html

]# firefox 172.25.0.11

########################################################
 DocumentRoot:设置存放网页文件的路径(设置网页文件根目录)
  
虚拟机server:
]# mkdir /var/www/myweb
]# echo '<h1>wo shi myweb' > /var/www/myweb/index.html

]# vim /etc/httpd/conf/httpd.conf   #全文命令模式下  搜索 /Doc

DocumentRoot  "/var/www/myweb"

]# systemctl restart httpd
]# firefox 172.25.0.11

######################################################
实际路径与网络路径(浏览器中输入的路径)

客户端:firefox 172.25.0.11:80 ----->服务端 httpd---->主配置 DocumenRoot /var/www/myweb -----> /var/www/myweb

客户端:firefox 172.25.0.11 
服务端:/var/www/myweb

客户端:firefox 172.25.0.11/abc
服务端:/var/www/myweb/abc

客户端:firefox 172.25.0.11/nsd
服务端:/var/www/myweb/nsd

DocumenRoot /var/www/myweb
客户端:firefox 172.25.0.11/var/www/myweb
服务端:/var/www/myweb/var/www/myweb

虚拟机server
]# mkdir /var/www/myweb/abc
]# echo '<h1>wo shi abc' > /var/www/myweb/abc/index.html
]# firefox 172.25.0.11/abc

#########################################################
Web访问控制,默认继承父目录访问控制

访问控制的配置字段:

<Directory  "/var/www">
    Require all granted   #允许所有人访问
</Directory>

<Directory  "/var/www">
    Require ip 172.25.0.10   #仅允许172.25.0.10访问
</Directory>

<Directory  "/var/www">
    Require all denied   #拒绝所有人访问
</Directory>
#######################################################
<Directory  "/var/www">
    Require all denied   #拒绝所有人访问
</Directory>

<Directory  "/var/www/test">
    Require all granted  #允许所有人访问
</Directory>

 /var/www/路径下的页面,拒绝所有人访问
 /var/www/test路径下的页面,允许所有人访问
 /var/www/abc路径下的页面,拒绝所有人访问
 /var/www/abc/nsd路径下的页面,拒绝所有人访问



#######################################################

案例:
修改网页文件,存放路径为/webroot
1.创建路径写入网页文件
]# mkdir /webroot
]# echo '<h1>wo shi webroot' > /webroot/index.html
]# ls /webroot/

2.修改配置文件
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf 
DocumentRoot "/webroot"

<Directory   "/webroot">    #针对/webroot进行访问控制配置
    Require  all  granted   #允许所有人访问
</Directory>
[root@server0 ~]# setenforce 0   #将SELinux设置宽松模式
[root@server0 ~]# getenforce     #查看SELinux状态

[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# firefox 172.25.0.11
#########################################################
虚拟Web主机
– 由同一台服务器提供多个不同的Web页面

• 区分方式
– 基于域名的虚拟主机
– 基于端口的虚拟主机
– 基于IP地址的虚拟主机

域名可以DNS解析 :
  DNS服务器虚拟机classroom

     server0.example.com
     www0.example.com
     webapp0.example.com

• 为每个虚拟站点添加配置
  <VirtualHost IP地址:端口>
    ServerName 此站点的DNS名称
    DocumentRoot 此站点的网页根目录
  </VirtualHost>




• 配置文件路径
– /etc/httpd/conf/httpd.conf  主配置文件
– /etc/httpd/conf.d/*.conf    调用配置文件


虚拟机server
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf #调用配置文件
<VirtualHost *:80>                   #启用虚拟Web主机功能
   ServerName  server0.example.com   #设置访问的域名
   DocumentRoot  /var/www/qq         #设置存放网页文件目录
</VirtualHost>

<VirtualHost *:80>                #启用虚拟Web主机功能
   ServerName  www0.example.com   #设置访问的域名
   DocumentRoot  /var/www/baidu   #设置存放网页文件目录
</VirtualHost>
           
[root@server0 ~]# mkdir /var/www/qq /var/www/baidu
[root@server0 ~]# echo '<h1>企鹅' > /var/www/qq/index.html
[root@server0 ~]# echo '<h1>百度' > /var/www/baidu/index.html
[root@server0 ~]# systemctl restart httpd

[root@desktop0 ~]# firefox server0.example.com    
[root@desktop0 ~]# firefox www0.example.com

#########################################################
 一旦使用了虚拟Web主机功能,所有的网站都必须使用虚拟Web主机实现
如果直接使用IP地址进行访问,默认会将第一个虚拟Web主机页面内容呈现

[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
   ServerName server0.example.com
   DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
   ServerName www0.example.com
   DocumentRoot /var/www/baidu
</VirtualHost>
<VirtualHost *:80>
   ServerName webapp0.example.com
   DocumentRoot /var/www/myweb
</VirtualHost>
[root@server0 ~]# systemctl  restart httpd

##########################################
Engineer05                              #
########################################
一  环境设置
虚拟机server
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@server0 ~]# firewall-cmd --get-default-zone
虚拟机desktop
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --get-default-zone

二 虚拟机server构建基于域名的虚拟Web主机
- 实现三个网站的部署
- 实现客户端访问server0.example.com网页内容为 卖女孩的小火柴
- 实现客户端访问www0.example.com网页内容为  奔跑吧骆驼
- 实现客户端访问webapp0.example.com网页内容为 20里春风不如你

[root@server0 ~]# yum -y install httpd
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost  *:80>
 ServerName  server0.example.com
 DocumentRoot /var/www/nsd01
</VirtualHost>
<VirtualHost  *:80>
 ServerName  www0.example.com                 
 DocumentRoot /var/www/nsd02
</VirtualHost>
<VirtualHost  *:80>
 ServerName  webapp0.example.com              
 DocumentRoot /var/www/nsd03
</VirtualHost>

]# cd /var/www/
]# mkdir nsd01 nsd02  nsd03
]# echo '<h1>卖女孩的小火柴' > /var/www/nsd01/index.html
]# echo '<h1>奔跑吧骆驼' > /var/www/nsd02/index.html
]# echo '<h1>20春风不如你' > /var/www/nsd03/index.html
]# systemctl restart httpd

###########################################################
文件夹权限
• 针对 DocumentRoot 网页目录的权限控制
• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的ACL访问权限
– 除非针对子目录有明确设置

案例1:虚拟机server配置网页内容访问
在 Web 网站 http://server0.example.com 的
DocumentRoot 目录下创建一个名为 private 的子目录,要求如下:

1.查看server0.example.com的DocumentRoot目录路径
]# cat /etc/httpd/conf.d/nsd01.conf 
]# mkdir /var/www/nsd01/private
]# echo '<h1>wo shi private' > /var/www/nsd01/private/index.html

]# firefox server0.example.com/private

2.从虚拟机server0上,任何人都可以浏览 private 的内容
但是从其他系统不能访问这个目录的内容
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf 
<Directory  "/var/www/nsd01/private">
    Require ip 172.25.0.11     #仅允许172.25.0.11进行访问
</Directory>

[root@server0 ~]# systemctl restart httpd


虚拟机desktop0:访问测试权限不足
]# firefox server0.example.com/private
Forbidden

You don't have permission to access /private/ on this server.

##########################################################
案例2:使用自定Web根目录
调整 Web 站点 http://server0.example.com 的网页
目录,要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
]# mkdir /webroot
]# echo '<h1>wo shi Webroot' > /webroot/index.html
]# ls /webroot/

[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost  *:80>
 ServerName  server0.example.com
 DocumentRoot /webroot
</VirtualHost>
........
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf
........
<Directory "/webroot">
    Require all granted
</Directory>

[root@server0 ~]# systemctl restart httpd




SELinux三大策略:  1.布尔值   2.安全上下文   3.非默认端口的开放    

[root@server0 ~]# setenforce 1       #开启SELinux
[root@server0 ~]# getenforce         #查看SELinux状态

SELinux安全上下文(标签值)
[root@server0 ~]# ls -Zd /var/www/   #查看目录的上下为值
[root@server0 ~]# ls -Zd /webroot/
• 方式1:参照标准目录,重设新目录的属性
– chcon [-R] --reference=模板目录   新目录

[root@server0 ~]# chcon -R --reference=/var/www  /webroot/
[root@server0 ~]# ls -Zd /webroot/

########################################################
部署动态网站

静态网站的运行
• 服务端的原始网页 = 浏览器访问到的网页
– 由Web服务软件处理所有请求
– 文本(txt/html)、图片(jpg/png)等静态资源

动态网站的运行
• 服务端的原始网页 ≠ 浏览器访问到的网页
– 由Web服务软件接受请求,动态程序转后端模块处理
– PHP网页、Python网页、JSP网页......


虚拟机server新建一个动态站点站点名称为 webapp0.example.com
1.部署Python页面
[root@server0 ~]# cat /etc/httpd/conf.d/nsd01.conf 
[root@server0 ~]# cd /var/www/nsd03
[root@server0 nsd03]# wget http://classroom.example.com/pub/materials/webinfo.wsgi

[root@server0 nsd03]# cat webinfo.wsgi

2.方便用户的访问,页面跳转(页面别名   地址重写)

浏览器中输入: firefox  webapp0.example.com
服务端:/var/www/nsd03/webinfo.wsgi

  Alias  网络路径     服务端实际路径

[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf

<VirtualHost *:80>
 ServerName  webapp0.example.com
 DocumentRoot /var/www/nsd03

 Alias   /      /var/www/nsd03/webinfo.wsgi

   #当客户端直接访问网页文件根目录时,呈现/var/www/nsd03/webinfo.wsgi页面内容

</VirtualHost>

[root@server0 /]# systemctl restart httpd
[root@server0 /]# firefox webapp0.example.com

3.安装mod_wsgi软件包,专用于翻译Python页面
[root@server0 /]# yum -y install mod_wsgi
[root@server0 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
 ServerName  webapp0.example.com
 DocumentRoot /var/www/nsd03
 WsgiScriptAlias   /      /var/www/nsd03/webinfo.wsgi

</VirtualHost>

[root@server0 /]# systemctl restart httpd

[root@desktop0 ~]# firefox webapp0.example.com
显示内容为 UNIX时间戳:从1970-1-1 0:0:0到达当前系统时间,所经历的秒数


4.此虚拟webapp0.example.com主机侦听在端口8909
[root@server0 /]# vim  /etc/httpd/conf.d/nsd01.conf
Listen 8909             #让httpd程序监听8909端口
<VirtualHost  *:8909>   #本虚拟Web主机使用8909端口
 ServerName    webapp0.example.com
 DocumentRoot  /var/www/nsd03
 WsgiScriptAlias   /      /var/www/nsd03/webinfo.wsgi
</VirtualHost>
      
5.SELinux非默认端口的开放    
-l:列出  -a:添加  -t:类型  -p:协议
]# semanage port -l | grep http
]# semanage port -a -t http_port_t  -p tcp 8909   #添加端口
             
]# systemctl restart httpd
]# firefox webapp0.example.com:8909
#########################################################
 1.端口的优先级最高
 2.默认将第一个虚拟Web主机内容呈现
#########################################################
安全Web服务,实现https(完全的超文本传输协议)

PKI公钥基础设施
• Public Key Infrastructure,公钥基础设施
– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作

虚拟机server:构建安全的Web服务

1.部署网站证书
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/tls/certs/server0.crt
]# ls

2.部署根证书
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/example-ca.crt
]# ls 

3.部署私钥(解密数据)
]# cd /etc/pki/tls/private/
]# wget http://classroom.example.com/pub/tls/private/server0.key

]# ls 

4.安装支持安全的软件
[root@server0 /]# yum -y install mod_ssl
[root@server0 /]# ls /etc/httpd/conf.d/ssl.conf 
[root@server0 /]# vim  /etc/httpd/conf.d/ssl.conf 
 vim末行模式  :set  nu   #开启行号功能

 59 DocumentRoot  "/var/www/html"
 60 ServerName   www0.example.com:443

#指定网站证书的路径及名称
100 SSLCertificateFile  /etc/pki/tls/certs/server0.crt
#指定解密的私钥
107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key
#指定根证书
122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt

5.书写一个网站
]# echo '<h1>haha xixi' > /var/www/html/index.html 

6.重启httpd服务
]# systemctl restart httpd

7.验证
[root@desktop0 ~]# firefox https://www0.example.com
   我已了解可能的风险--->添加例外---->确认例外

##########################################
Engineer06                              #
########################################
一  环境设置
虚拟机server
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 
[root@server0 ~]# firewall-cmd --get-default-zone
虚拟机desktop
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
[root@desktop0 ~]# firewall-cmd --get-default-zone

#########################################################
二 网络参数配置
方式一:nmtui

方式二:
1.设置永久设置主机名,修改/etc/hostname配置文件

[root@server0 ~]# echo A.tedu.cn > /etc/hostname  
[root@server0 ~]# hostname
A.tedu.cn
[root@server0 ~]# exit
登出
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ gos
Last login: Fri May 17 09:04:25 2019 from 172.25.0.250
[root@A ~]# 

2.配置IP地址,子网掩码,网关地址

1)查看识别的网卡名称
[root@A ~]# nmcli connection show 
名称         
System eth0

2)修改IP地址,子网掩码,网关地址                                    
]#  nmcli connection modify 'System eth0'     
    ipv4.method manual 
    ipv4.addresses '172.25.0.112/24   172.25.0.254' 
    connection.autoconnect yes 

]#  nmcli connection 修改  '识别的网卡名'
    ipv4.方法  手工配置IP地址
    ipv4.地址  'IP地址/子网掩码   网关地址'
       每次开机自动启用 

3)激活配置
[root@A ~]# ifconfig | head -2
[root@A ~]# nmcli connection up 'System eth0'
######################################################
DNS服务器地址:将域名解析为对应的IP地址
/etc/resolv.conf  #指定DNS服务器最终有效配置文件

]# echo 'nameserver  172.25.254.254'  >   /etc/resolv.conf

]# cat /etc/resolv.conf
nameserver  172.25.254.254

]# nslookup  www0.example.com    #测试域名解析
Server:		172.25.254.254
Address:	172.25.254.254#53

www0.example.com	canonical name = server0.example.com.
Name:	server0.example.com
Address: 172.25.0.11
#######################################################
配置IPv6地址

• IPv4 地址表示
– 32个二进制位,点分隔的十进制数
– 例如:172.25.0.11、127.0.0.1

• IPv6 地址表示
– 128个二进制位,冒号分隔的十六进制数
– 每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::

– 例如: 2003:ac18:0000:0000:0000:0000:0000:0305
      2003:ac18::305/64


1)查看识别的网卡名称
[root@A ~]# nmcli connection show 
2)修改IP地址,子网掩码,网关地址                                    
]#  nmcli connection modify 'System eth0'     
    ipv6.method manual 
    ipv6.addresses 2003:ac18::305/64 
    connection.autoconnect yes 

]#  nmcli connection 修改  '识别的网卡名'
    ipv6.方法  手工配置IP地址
    ipv6.地址  IP地址/子网掩码
       每次开机自动启用 

3)激活配置
[root@A ~]# ifconfig | head -4
[root@A ~]# nmcli connection up 'System eth0'
[root@A ~]# ifconfig | head -4
[root@A ~]# ping6 2003:ac18::305
#########################################################
链路聚合(聚合链路 网卡绑定)                     

   作用:提高网卡设备的可靠性,提供冗余    
   

                eth1          eth2    
                     
                                 虚拟网卡:team0 
                                  192.168.1.1


1.建立虚拟网卡team0,参考 man teamd.conf   全文搜索 /example

]# nmcli connection add type team             
   con-name team0 ifname team0 autoconnect yes         
   config  '{"runner": {"name": "activebackup"}}'

]# nmcli connection 添加  类型  team
     配置文件名  team0 网卡名 team0  每次开机自动启用
     链路聚合管理方式为 热备份方式


]# ifconfig   #查看生成的虚拟网卡team0

生成配置文件位置:/etc/sysconfig/network-scripts/

2.添加成员
]# nmcli connection add type team-slave       
   con-name team0-1 ifname eth1 master team0 

]# nmcli connection add type team-slave       
   con-name team0-2 ifname eth2 master team0 


]# nmcli connection 添加   类型  team-成员
     配置文件名   team0-1  网卡名  eth1  主设备为 team0

生成配置文件位置:/etc/sysconfig/network-scripts/

3.配置IP地址激活
[root@A ~]# nmcli connection modify team0 ipv4.method manual ipv4.addresses 192.168.1.1/24 connection.autoconnect  yes

[root@A ~]# nmcli connection up team0  #激活配置

[root@A ~]# teamdctl team0 state    #专用于查看team0信息
[root@A ~]# ifconfig eth2 down      #禁用eth2网卡
[root@A ~]# teamdctl team0 state

如果无法激活,删除所有配置重新来过
[root@A ~]# nmcli connection delete team0
[root@A ~]# nmcli connection delete team0-1
[root@A ~]# nmcli connection delete team0-2

###################################################
parted分区工具,进行gpt分区模式

       128个主分区 最大空间支持18EB

[root@A ~]# parted  /dev/vdb
(parted) mktable  gpt        #指定分区表类型为gpt
(parted) print               #输出分区表信息
(parted) mkpart              #划分新的分区
分区名称？  []? haha             #分区名称随意写
文件系统类型？  [ext2]? ext4     #文件系统随意些,不起实际作用
起始点？ 0                                    #分区起始点
结束点？ 2G                   #分区结束点
警告: The resulting partition is not properly aligned
for best performance.
忽略/Ignore/放弃/Cancel? Ignore    #选择ignore忽略
(parted) print               
(parted) unit  GB             #使用GB最为单位
(parted) print
(parted) mkpart 
分区名称？  []? haha 
文件系统类型？  [ext2]? ext4
起始点？ 2G
结束点？ 5G
(parted) print
(parted) quit
###################################################
基础邮件服务

邮件域名:
   server0.example.com

邮箱帐号:
   yg@server0.example.com


• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱

快速部署postfix邮件服务器
1.装postfix软件包
[root@A ~]# rpm -q postfix
postfix-2.10.1-6.el7.x86_64

2.修改配置文件/etc/postfix/main.cf 
vim末行模式 :set  nu    #开启行号

99  myorigin = server0.example.com  #默认补全域名后缀

116 inet_interfaces = all   #允许本机所有网卡提供邮件服务

164 mydestination = server0.example.com #此值判断为本域邮件

3.重启服务                                                      
[root@A ~]# systemctl  restart  postfix


测试邮件收发
[root@A ~]# useradd yg
[root@A ~]# useradd xln

•发信操作: mail -s '邮件标题'    -r  发件人      收件人
[root@A ~]# mail -s 'test01' -r yg  xln
ahahxixihehelele
.
EOT
[root@A ~]# echo AAA | mail -s 'test02' -r yg  xln

•收信操作: mail [-u 用户名]
[root@A ~]# mail -u xln
>N  1 yg@server0.example.c  Fri May 17 15:28  18/565   
& 1     #输入邮件编号1回车查看邮件的内容

##########################################
Services01                              #
########################################
搭建新教学环境

一  关闭虚拟机classroom与server与desktop

二  真机建立全新的两台虚拟机
[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 4

[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 5

   vi是Linux最基本的编辑器 

虚拟机root的密码:123456

##################################################
三   配置虚拟机A
1.为虚拟机A:配置eth0的IP地址为192.168.4.7/24
真机管理本机虚拟机,前提关闭所有虚拟机图形窗口             
[student@room9pc01 ~]$ virsh  console  A
   Ctrl +  ]:退出管理
[root@localhost ~]# nmcli connection modify eth0 ipv4.method manual ipv4.address 192.168.4.7/24 connection.autoconnect yes

[root@localhost ~]# nmcli connection up eth0
[root@localhost ~]# ifconfig | head -2
2.为虚拟机A配置主机名:svr7.tedu.cn
[root@localhost ~]# echo svr7.tedu.cn  > /etc/hostname
svr7.tedu.cn
[root@localhost ~]# hostname svr7.tedu.cn
[root@localhost ~]# hostname
svr7.tedu.cn
[root@svr7 ~]# cat /etc/motd   #每次开机自动显示内容

###################################################
真机利用virsh console管理虚拟机B进行配置
[root@localhost ~]# hostname pc207.tedu.cn
[root@localhost ~]# echo pc207.tedu.cn > /etc/hostname 

[root@localhost ~]# nmcli connection modify eth0 ipv4.method manual ipv4.address 192.168.4.207/24 connection.autoconnect yes

[root@localhost ~]# nmcli connection up eth0
[root@localhost ~]# ifconfig | head -2

###################################################
利用真机进行ssh远程管理
真机上设置
[student@room9pc01 ~]$ vim /home/student/.bashrc
alias goa='ssh  -X  root@192.168.4.7'
alias gob='ssh  -X  root@192.168.4.207'

 开启新的终端才能验证

###################################################
为虚拟机A与虚拟机B构建Yum仓库

一 真机:服务端 
      构建Web服务或FTP服务,共享光盘所有内容

1.构建FTP服务,共享光盘所有内容                               
[student@room9pc01 ~]$ rpm -q vsftpd
vsftpd-3.0.2-22.el7.x86_64
[student@room9pc01 ~]$ ls /var/ftp/centos-1804/

[student@room9pc01 ~]$ systemctl status vsftpd

[student@room9pc01 ~]$ vim /etc/fstab
..........
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0

]$ firefox ftp://192.168.4.254/centos-1804  

二 客户端:虚拟机A与虚拟机B
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[root@svr7 ~]# yum  repolist
[root@svr7 ~]# yum -y install xeyes

[root@svr7 ~]# xeyes

###################################################
总结新建虚拟机:
1.真机利用clone-vm7生成虚拟机,开启虚拟机
2.真机利用virsh console  虚拟机名   设置IP地址
3.真机利用ssh远程管理虚拟机,配置主机名与Yum客户端配置文件

####################################################
虚拟机C
   1.配置eth0的IP地址:192.168.4.10/24
   2.配置主机名:svr10.tedu.cn
   3.配置Yum仓库,以真机提供FTP作为服务端

虚拟机D
   1.配置eth0的IP地址:192.168.4.20/24
   2.配置主机名:pc20.tedu.cn
   3.配置Yum仓库,以真机提供FTP作为服务端




####################################################

目录结构
• 认识Linux的目录层次:
– man hier

• 常见一级目录的用途
	/boot        存放系统引导必需的文件,包括内核、启动配置
	/bin、/sbin  存放各种命令程序
	/dev         存放硬盘、键盘、鼠标、光驱等各种设备文件
	/etc         存放Linux系统及各种程序的配置文件
	/root、/home/用户名   分别是管理员root、普通用户的默认家目录
	/var         存放日志文件、邮箱目录等经常变化的文件
	/proc        存放内存中的映射数据,不占用磁盘
	/tmp         存放系统运行过程中使用的一些临时文件

权限的数值表示
• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1

[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 700 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 007 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 755 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 750 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 3755 /nsd01
[root@svr7 ~]# ls -ld /nsd01

###################################################
历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令
• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000    #默认记录1000条


[root@svr7 ~]# history        #查看历史命令
[root@svr7 ~]# history -c     #清空历史命令
[root@svr7 ~]# history 
    1  history 
[root@svr7 ~]# cat /etc/redhat-release 
[root@svr7 ~]# ls -l /etc/redhat-release
[root@svr7 ~]# cat /etc/hostname

[root@svr7 ~]# history 

[root@svr7 ~]# !cat     #执行历史命令中最近一条cat开头

###################################################
实用小命令工具
• du,统计文件的占用空间
– du [选项]... [目录或文件]...

– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du -s /root/

[root@svr7 ~]# du -sh /root/

[root@svr7 ~]# du -sh  /boot/ /etc/

[root@svr7 ~]# du -sh /

################################################
bc 交互式计算器
[root@svr7 ~]# bc
-bash: bc: 未找到命令
[root@svr7 ~]# yum -y install bc

[root@svr7 ~]# bc     #进入交互式模式
   +   -   *   /     %(取余数运算)

公式是:  被除数 ÷ 除数 = 商

  余数一定小于除数
   
##################################################
• date,查看/调整系统日期时间
– date +%F、date +%R
– date +"%Y-%m-%d %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"

[root@svr7 ~]# date +%F   #显示年月日 
[root@svr7 ~]# date +%R   #显示时分

[root@svr7 ~]# date +%Y   #显示年
[root@svr7 ~]# date +%m   #显示月

[root@svr7 ~]# date +%d   #显示日期
[root@svr7 ~]# date +%H   #显示时

[root@svr7 ~]# date +%M   #显示分
[root@svr7 ~]# date +%S   #显示秒

#####################################################
制作快捷方式(连接文件 符号文件)

格式:ln -s   /路径/源文件    /路径/生成快捷方式名称       #软连接

[root@svr7 ~]# cat /etc/hostname 

[root@svr7 ~]# ln -s /etc/hostname  /
[root@svr7 ~]# ls /
[root@svr7 ~]# ls -l /hostname 

[root@svr7 ~]# ln -s /etc/hostname  /hn
[root@svr7 ~]# ls   /
[root@svr7 ~]# ls -l  /hn

[root@svr7 ~]# cat /hn
[root@svr7 ~]# cat /hostname

若原始文件或目录被删除,连接文件将失效
软连接可存放在不同分区/文件系统,也可以针对目录

[root@svr7 ~]# echo 123 > /opt/A
[root@svr7 ~]# cat /opt/A
123
[root@svr7 ~]# ln -s /opt/A  /opt/B
[root@svr7 ~]# ls /opt/
A  B
[root@svr7 ~]# rm -rf /opt/A
[root@svr7 ~]# ls /opt/
B
[root@svr7 ~]# cat /opt/B

ln,创建硬连接
– ln 原始文件   硬连接文件

 若原始文件被删除,连接文件仍可用
 硬连接与原始文件必须在同一分区/文件系统,必须时文件

[root@svr7 ~]# echo haha > /opt/1.txt
[root@svr7 ~]# ln /opt/1.txt /opt/2.txt
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# cat /opt/2.txt 

[root@svr7 ~]# rm -rf /opt/1.txt 
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# cat /opt/2.txt 
####################################################

获取命令帮助
[root@svr7 ~]# date --help
[root@svr7 ~]# man date

[root@svr7 ~]# man passwd
[root@svr7 ~]# man 5 passwd   #配置文件帮助信息
###################################################
zip归档工具(跨平台的压缩工具)

• 归档+压缩操作
– zip [-r]  备份文件.zip   被归档的文档...
[root@svr7 ~]# yum -y install zip
[root@svr7 ~]# zip -r /opt/file.zip /etc/passwd /home
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# zip -r /opt/abc.zip /etc/fstab /etc/hosts
[root@svr7 ~]# ls /opt/

• 释放归档+解压操作
– unzip 备份文件.zip [-d 目标文件夹]
[root@svr7 ~]# yum -y install unzip
[root@svr7 ~]# mkdir /nsd02
[root@svr7 ~]# unzip /opt/file.zip -d /nsd02

[root@svr7 ~]# ls /nsd02
[root@svr7 ~]# ls /nsd02/etc/
[root@svr7 ~]# ls /nsd02/home/
####################################################
发布自定义Yum仓库

   把从互联网下载的软件包,采用Yum的机制进行管理

1.具备从互联网下载的软件包
真机上:
[student@room9pc01 ~]$ ls /linux-soft/01    
Cobbler.zip  tools.tar.gz

2.将真机tools.tar.gz上传到虚拟机A的/root目录下
  scp=ssh+cp结合
  scp   /本地路径/源文件   root@对方IP地址:/目标路径/

scp /linux-soft/01/tools.tar.gz  root@192.168.4.7:/root

3.验证在虚拟机A进行查看
[root@svr7 ~]# ls /root/
Desktop  tools.tar.gz
[root@svr7 ~]# 

4.虚拟机A解包:
[root@svr7 ~]# tar -xf /root/tools.tar.gz -C /
[root@svr7 ~]# ls /
[root@svr7 ~]# ls /tools/
[root@svr7 ~]# ls /tools/other/

5.生成仓库清单(仓库数据文件)
[root@svr7 ~]# yum -y install createrepo
[root@svr7 ~]# createrepo /tools/other/

[root@svr7 ~]# ls /tools/other/

6.修改配置文件指定新的Yum服务端
[root@svr7 ~]# ls /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[myrpm]
name=myrpm
baseurl=file:///tools/other      #指定本机为服务端
enabled=1
gpgcheck=0

[root@svr7 ~]# yum  repolist

##################################################
[root@svr7 ~]# yum -y install cmatrix
[root@svr7 ~]# cmatrix

[root@svr7 ~]# yum -y install sl
[root@svr7 ~]# sl

[root@svr7 ~]# yum -y install oneko
[root@svr7 ~]# oneko &
     关闭终端,可以结束oneko程序

##################################################
vim编辑技巧

命令模式
[root@svr7 ~]# cp  /etc/passwd   /opt/pa.txt
[root@svr7 ~]# vim  /opt/pa.txt             
光标跳转
	Home 键 或 ^、数字 0 	跳转到行首
	End 键 或“$”键 			跳转到行尾
	1G 或 gg 				跳转到文件的首行
	G 					跳转到文件的末尾行
复制/粘贴/删除
	复制 yy、#yy 		复制光标处的一行、#行
	粘贴 p、P 		粘贴到光标处之后、之前
	x 或 Delete键 		删除光标处的单个字符
	dd、#dd 			删除光标处的一行、#行
	d^ 				从光标处之前删除至行首
	d$或D(大写) 		从光标处删除到行尾
	C(大写) 			从光标处删除到行尾,并且进入插入模式
	u                	撤销

查找/撤销/保存
	/word 	向后查找字符串“word”
	n、N 	跳至后/前一个结果
	u 		撤销最近的一次操作
	U 		撤销对当前行的所有修改
	Ctrl + r 取消前一次撤销操作
	ZZ(大写)	保存修改并退出
[root@svr7 ~]# cp /etc/passwd /opt/pa.txt 
cp：是否覆盖"/opt/pa.txt"？ y
[root@svr7 ~]# vim  /opt/pa.txt


####################################################
末行模式操作

读入其他文件内容

[root@svr7 ~]# echo 123 > /opt/a.txt
[root@svr7 ~]# echo abc > /opt/b.txt
[root@svr7 ~]# vim /opt/a.txt

      末行模式下   :r  /opt/b.txt   #读入/opt/b.txt内容到当前文件
      末行模式下   :r  /etc/hostname
      末行模式下   :r  /etc/hosts
 
字符串替换
	:s/root/admin 		替换光标所在的当前行第一个“root”
	:s/root/admin/g 		替换光标所在的当前行所有的“root”
	:5,10 s/root/admin/g 		替换第5-10行所有的“root”
	:% s/root/admin/g 		替换文件内所有的“root”

[root@svr7 ~]# cp /etc/passwd /opt/p.txt
[root@svr7 ~]# vim /opt/p.txt

开关参数的控制                                                
	:set nu或nonu 	显示/不显示行号
	:set ai或noai 	启用/关闭自动缩进

###############################################
源码编译安装

RPM包:  rpm  -ivh    yum  

源码包----gcc与make---->可以执行的文件------->运行安装

源码编译安装的优势
• 主要优点
 – 获得软件的最新版,及时修复bug
 – 软件功能可按需选择/定制,有更多软件可供选择
 – 源码包适用各种平台

步骤1:安装依赖关系包(安装开发工具)
[root@svr7 ~]# yum -y install  gcc  make
[root@svr7 ~]# rpm -q gcc
gcc-4.8.5-28.el7.x86_64
[root@svr7 ~]# rpm -q make
make-3.82-23.el7.x86_64

步骤2:tar解包,释放源代码至指定目录
]# tar -xf /tools/inotify-tools-3.13.tar.gz -C  /
]# ls /
]# cd /inotify-tools-3.13/
]# ls

步骤3: ./configure 配置,指定安装目录/功能模块等选项
  
            ./=当前路径下运行    作用1:检测本机是否安装gcc
                                          作用2:指定安装目录/功能模块等选项

       --prefix=指定安装位置

]# cd /inotify-tools-3.13/
]# ./configure --prefix=/mnt/myrpm

常见报错提示:没有安装gcc
checking for gcc... no
checking for cc... no
checking for cl.exe... no
configure: error: no acceptable C compiler found in $PATH
See `config.log' for more details.

步骤4:make 编译,生成可执行的二进制程序文件
]# cd /inotify-tools-3.13/
]# make

步骤5:make install 安装,将编译好的文件复制到安装目录
]# cd /inotify-tools-3.13/
]# make install

]# ls /mnt/
]# ls /mnt/myrpm/         #查看安装生成的目录
]# ls /mnt/myrpm/bin/

##########################################
Services02                              #
########################################
一   真机远程管理虚拟机A

虚拟化概述
• virtualization 资源管理
– x个物理资源 --> y个逻辑资源
– 实现程度:完全、部分、硬件辅助(CPU)

 CPU能够直接识别运算虚拟机指令

虚拟机A:
[root@svr7 ~]# lscpu | grep vmx   #查看CPU是否支持虚拟化

真机查看CPU是否支持虚拟化
[student@room9pc01 ~]$ lscpu | grep vmx

####################################################
• 虚拟化主要厂商及产品
	VMware 		VMware Workstation、vSphere
	Microsoft 	VirtualPC、Hyper-V
	RedHat 		KVM、RHEV
	Citrix 		Xen
	Oracle 		Oracle VM VirtualBox

####################################################
二  手动安装一台有图形的虚拟机nsd01     
  
  操作系统为:CentOS 7.5
  内存为:2048M
  硬盘大小:9G 
 cpu:1
  虚拟名为:nsd01
  网络类型:private1
  软件包选择:带GUI的服务器
  分区:自动分区

 root密码设置为1     创建lisi用户密码设置为1
####################################################
三   针对虚拟机nsd01进行配置

  1.关闭SELinux  
[root@localhost ~]# getenforce 
[root@localhost ~]# setenforce 0
[root@localhost ~]# vim /etc/selinux/config 
SELINUX=permissive
  2.防火墙设置为trusted
  3.设置IP地址为:192.168.4.30/24
]# nmcli connection modify eth0       
 ipv4.method manual ipv4.addresses 192.168.4.30/24    
 connection.autoconnect yes
]# nmcli connection up eth0 
]# ifconfig | head -2
  4.主机名:kvm.tedu.cn
  5.构建Yum仓库,使用真机FTP最为服务端
[root@localhost yum.repos.d]# mkdir  repo
[root@localhost yum.repos.d]# mv  *.repo   repo

###################################################
虚拟机nsd01:安装虚拟化服务器平台
• 主要软件包
– qemu-kvm:为 kvm 提供底层仿真支持
– libvirt-daemon:libvirtd 守护进程,管理虚拟机
– libvirt-client:用户端软件,提供客户端管理命令
– libvirt-daemon-driver-qemu:libvirtd 连接 qemu 的驱动
– virt-manager:图形管理工具

[root@kvm ~]# yum -y install qemu-kvm 
[root@kvm ~]# yum -y install libvirt-daemon
[root@kvm ~]# yum -y install libvirt-daemon-driver-qemu
 
[root@kvm ~]# yum -y install libvirt-client 
[root@kvm ~]# yum -y install virt-manager

[root@kvm ~]# virt-manager   #图形虚拟系统管理器

####################################################
虚拟化服务:
[root@kvm ~]# systemctl status libvirtd

####################################################
真机上进行虚拟机管理:             
virsh命令工具介绍
• 查看KVM节点(服务器)信息
– virsh nodeinfo
• 列出虚拟机
– virsh list [--all]
• 查看指定虚拟机的信息
– virsh dominfo 虚拟机名称
• 将指定的虚拟机设为开机自动运行
– virsh autostart [--disable] 虚拟机名称
• 强制关闭指定的虚拟机
– virsh destroy 虚拟机名称
• 运行|重启|关闭指定的虚拟机
– virsh start  虚拟机名称

###################################################
xml配置文件(虚拟机描述文件)

默认存放路径:
[student@room9pc01 ~]$ ls /etc/libvirt/qemu

输出虚拟机xml文件内容
[student@room9pc01 ~]$ virsh dumpxml nsd01 | less
   
   虚拟机名称:  <name>nsd01</name>
  <uuid>cf4e78cb-65bb-48df-a84b-56741a470fcb</uuid>
  <source file='/var/lib/libvirt/images/nsd01.qcow2'/>
   网卡MAC地址:网卡唯一编号<mac address='52:54:00:20:37:74'/>


###################################################
一台KVM虚拟机的组成
 – xml配置文件:定义虚拟机的名称、UUID、CPU、内
存、虚拟磁盘、网卡等各种参数设置
默认路径:/etc/libvirt/qemu

 – 磁盘镜像文件:保存虚拟机的操作系统及文档数据,
镜像路径取决于xml配置文件中的定义
默认路径:/var/lib/libvirt/images/

真机:手动创建一个虚拟机abc01
1.创建虚拟机磁盘镜像文件
]$ cd  /var/lib/libvirt/images/
]$ cp  .node_tedu.qcow2       abc01.qcow2

2.创建虚拟机xml配置文件
]$ virsh dumpxml nsd01 > /etc/libvirt/qemu/abc01.xml
]$ ls /etc/libvirt/qemu
]$ ls -l /etc/libvirt/qemu/abc01.xml 
]$ vim /etc/libvirt/qemu/abc01.xml
    虚拟机名称:  <name>abc01</name>

  <uuid>删除整行内容,如果删多了按u进行撤销

  <source file='/var/lib/libvirt/images/abc01.qcow2'/>

  <mac address='52:54:00:20:37:74'/> 删除整行内容

3.导入虚拟机信息
]$ virsh define /etc/libvirt/qemu/abc01.xml 

]$ virsh list --all
]$ virsh start abc01
]$ virsh list

###################################################
手动创建虚拟机:
1.创建新的虚拟机磁盘文件
2.导出虚拟机xml配置文件
]$ virsh dumpxml nsd01 > /etc/libvirt/qemu/abc01.xml
]$ vim /etc/libvirt/qemu/abc01.xml
    虚拟机名称:  <name>abc01</name>
  <uuid>删除整行内容,如果删多了按u进行撤销
  <source file='/var/lib/libvirt/images/abc01.qcow2'/>
  <mac address='52:54:00:20:37:74'/> 删除整行内容

3.导入虚拟机信息
]$ virsh define /etc/libvirt/qemu/abc01.xml 

##################################################
三合一的命令:导出xml配置文件      修改    导入

1.创建一个虚拟机磁盘文件
]$ cd /var/lib/libvirt/images/
]$ cp .node_tedu.qcow2      abc02.qcow2

2.三合一的命令:导出xml配置文件      修改    导入
[student@room9pc01 /]$ virsh edit nsd01
    虚拟机名称:  <name>abc02</name>
  <uuid>删除整行内容,如果删多了按u进行撤销
  <source file='/var/lib/libvirt/images/abc02.qcow2'/>
  <mac address='52:54:00:20:37:74'/> 删除整行内容

[student@room9pc01 /]$ virsh list --all
[student@room9pc01 /]$ virsh start  abc02

###################################################
虚拟机命令行的删除
[student@room9pc01 /]$ virsh list 
[student@room9pc01 /]$ virsh destroy abc02  #强制关机
域 abc02 被删除

[student@room9pc01 /]$ virsh list --all
[student@room9pc01 /]$ virsh undefine abc02  #取消定义
域 abc02 已经被取消定义

]$ virsh list --all
]$ cd /var/lib/libvirt/images/
]$ ls abc02.qcow2   
]$ rm -rf abc02.qcow2   #删除磁盘文件
]$ ls
##################################################
COW(Copy On Write)机制  写时复制

• 虚拟机的磁盘镜像文件格式
	特点\类型 		RAW		   QCOW2
	KVM默认 		否 			是
	I/O效率 		高 			较高
	占用空间 		大 			小
	压缩 			不支持 		支持
	后端盘复用 	不支持 		支持
	快照 			不支持 		支持

– 直接映射原始盘的数据内容
– 当前端盘的数据有修改时,在修改之前自动将原始盘的旧数据存入前端盘
– 对前端盘的修改不回写到原始盘

 前端盘大小最好比原始盘大或相等

1.基于原始盘.node_tedu.qcow2生成前端盘test.qcow2  
]$ cd /var/lib/libvirt/images/
]$ qemu-img create  -f qcow2   -b .node_tedu.qcow2   test.qcow2 10G

]$ qemu-img info test.qcow2   #查看磁盘文件信息

2.修改虚拟机xml文件内容
]$ virsh edit nsd01
     虚拟机名称:  <name>test</name>
   <uuid>删除整行内容,如果删多了按u进行撤销
   <source file='/var/lib/libvirt/images/test.qcow2'/>
   <mac address='52:54:00:20:37:74'/> 删除整行内容

]$ virsh  start test
]$ virsh  list  --all   

###################################################
离线访问虚拟机:虚拟机关机状态,直接修改磁盘文件里面的数据

]$ guestmount -a /var/lib/libvirt/images/tedu_node09.img  -i /home/student/nsdfile/

##########################################
Services03                              #
########################################




• DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址
– 反向解析:根据IP地址查找对应的注册域名,不常用

所有的域名都必须以点作为结尾

根域：　　　　　　　　．
　　
一级域名：　.cn    .us   .tw   .hk   .jp  .kr


二级域名：　tedu.cn    .com.cn   .net.cn   .org.cn


三级域名：　nb.com.cn   haha.com.cn  haxi.com.cn  


完全合格的主机名:  主机头部+域名

  该网站的FQDN为: www.qq.com

Full Qualified Domain Name(FQDN),完全合格主机名

###################################################
bind-9.9.4-29.el7.x86_64   //域名服务包
bind-chroot-9.9.4-29.el7.x86_64  //提供虚拟根支持,牢笼政策

– 系统服务:named
– 默认端口:TCP/UDP 53
– 运行时的虚拟根环境:/var/named/chroot/

• 主配置文件:/etc/named.conf    #设置负责解析域名   tedu.cn
• 地址库文件:/var/named/        #记录域名与IP地址对应关系
              
虚拟机A构建DNS服务
1.安装软件
[root@svr7 ~]# yum -y install  bind  bind-chroot
2.修改主配置文件
[root@svr7 ~]# cp /etc/named.conf /etc/named.bak
[root@svr7 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";   #地址库文件存放路径
};
zone "tedu.cn" IN {          #设置负责解析的域名
        type master;         #类型为主DNS服务器
        file "tedu.cn.zone"; #地址库文件名称
};

3.建立地址库文件
[root@svr7 ~]# cd /var/named/
[root@svr7 named]# cp -p named.localhost tedu.cn.zone
        -p:保持源文件属性不变
[root@svr7 named]# ls -l tedu.cn.zone
[root@svr7 named]# vim  tedu.cn.zone
所有的域名都必须以点结尾
如果没有以点结尾,那么自动补全本地址库负责的域名

tedu.cn.  NS   svr7
svr7      A    192.168.4.7
www       A    1.1.1.1
ftp       A    2.2.2.2

[root@svr7 named]# systemctl  restart named

虚拟机B测试域名解析

1.指定本机DNS服务器/etc/resolv.conf 
]# echo nameserver 192.168.4.7  >  /etc/resolv.conf 
]# cat /etc/resolv.conf

]# nslookup www.tedu.cn
]# nslookup ftp.tedu.cn
##################################################
多区域的DNS服务器
1.修改主配置文件                                             
options {
        directory       "/var/named";
};
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
2.建立地址库文件qq.com.zone
 qq.com.   NS   svr7
 svr7      A    192.168.4.7
 www       A    3.3.3.3
 ftp       A    4.4.4.4


3.重启named服务

###################################################
搭建DNS服务器,实现www.sina.com解析结果为192.168.4.100

###################################################
DNS服务器资源解析记录:
  NS解析记录 
  A正向地址解析记录
  CNAME解析记录的别名

##################################################
特殊的解析记录
1.DNS轮询,基于DNS的站点负载均衡
– 一个域名 ---> 多个不同IP地址
[root@svr7 /]# vim /var/named/tedu.cn.zone  
tedu.cn.  NS   svr7
svr7      A    192.168.4.7
www       A    192.168.4.1
www       A    192.168.4.2
www       A    192.168.4.3
ftp       A    2.2.2.2

2.泛域名解析

虚拟机A
[root@svr7 /]# vim /var/named/tedu.cn.zone
 最后追加写入
 *         A    1.2.3.4
 tedu.cn.  A    10.20.30.40

[root@svr7 /]# systemctl  restart named

虚拟机B
[root@pc207 /]# nslookup wwww.tedu.cn
[root@pc207 /]# nslookup haxi.tedu.cn
[root@pc207 /]# nslookup tedu.cn

3.有规律的泛域名解析
    pc1.tedu.cn ------>192.168.10.1
    pc2.tedu.cn ------>192.168.10.2
    pc3.tedu.cn ------>192.168.10.3
    pc4.tedu.cn ------>192.168.10.4
        ..........
    pc50.tedu.cn ------>192.168.10.50

内置函数: $GENERATE  制造连续范围数字

虚拟机A
[root@svr7 /]# vim  /var/named/tedu.cn.zone
    最后追加写入

  $GENERATE 1-50  pc$  A  192.168.10.$

[root@svr7 /]# systemctl  restart named

虚拟机B
[root@pc207 /]# nslookup pc1.tedu.cn
[root@pc207 /]# nslookup pc2.tedu.cn

4.解析记录的别名
[root@svr7 /]# vim /var/named/tedu.cn.zone  
 最后追加写入
 tts       CNAME   ftp

[root@svr7 /]# systemctl  restart named

虚拟机B
[root@pc207 /]# nslookup  tts.tedu.cn

###################################################
主机名映射文件:/etc/hosts
  1.解析域名过程中,最高优先级
  2.只为本机提供解析

虚拟机A:
[root@svr7 /]# vim /etc/hosts
[root@svr7 /]# tail -1 /etc/hosts
最后追加写入

192.168.4.110  www.360.com

[root@svr7 /]# ping  www.360.com

###################################################
虚拟机B,构建DNS服务器,负责解析bj.qq.com
1.安装软件bind  bind-chroot
2.修改主配置文件
options {
        directory       "/var/named";
};      
zone "bj.qq.com" IN {
        type master;
        file "bj.qq.com.zone";
}; 
[root@pc207 ~]# cd /var/named/
[root@pc207 named]# cp -p named.localhost bj.qq.com.zone
[root@pc207 named]# vim bj.qq.com.zone
  bj.qq.com.      NS      pc207
  pc207           A       192.168.4.207
  www             A       11.12.13.14
[root@pc207 named]# systemctl restart named

####################################################
DNS子域授权

   父域:www.qq.com
   子域:www.bj.qq.com

  虚拟机A为DNS服务,负责qq.com域名的解析
  虚拟机B为DNS服务,负责bj.qq.com域名的解析

[root@pc207 /]# nslookup www.qq.com 192.168.4.7
[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.207

解析请求www.bj.qq.com询问父域DNS服务器虚拟机A,也能够解析
虚拟机A:
[root@svr7 ~]# vim /var/named/qq.com.zone    
 qq.com.    NS   svr7
 bj.qq.com. NS   pc207
 svr7       A    192.168.4.7
 pc207      A    192.168.4.207
 www        A    3.3.3.3
 ftp        A    4.4.4.4
[root@svr7 ~]# systemctl restart named

[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.7
Server:		 192.168.4.7
Address:	      192.168.4.7#53

Non-authoritative answer:   #非权威解答
Name:	www.bj.qq.com
Address: 11.12.13.14

 

递归查询
     客户端请求域名解析,主DNS服务器与其他DNS服务器交互,最终将解析结果带回来

[root@svr7 ~]# vim /etc/named.conf      
options {
        directory       "/var/named";
        recursion no;    #禁止DNS递归查询
};

迭代查询
      主DNS服务器与其他DNS服务器交互

####################################################
缓存DNS服务器,缓存解析记录加快解析

虚拟机A:互联网真DNS服务器                           
虚拟机B:缓存DNS服务器
虚拟机C:测试客户端

虚拟机C解析请求发送给虚拟机B,虚拟机B将请求发送给虚拟机A

一  准备虚拟机C,配置IP地址为192.168.4.10/24

二  配置虚拟机B
[root@pc207 /]# vim /etc/named.conf 
options {
        directory       "/var/named";
        forwarders { 192.168.4.7; };  #转发给192.168.4.7
};
[root@pc207 /]# systemctl restart named
[root@pc207 /]# nslookup www.tedu.cn 192.168.4.207
 
###################################################
综合实验:
 虚拟机A:DNS服务器
 虚拟机B:Web服务器,提供www.tedu.cn与www.qq.com
 虚拟机C:客户端测试

虚拟机B:
1.安装httpd软件包
[root@pc207 /]# yum -y install httpd
2.建立调用配置文件
[root@pc207 /]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName www.tedu.cn
  DocumentRoot /var/www/tedu
</VirtualHost>
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
[root@pc207 /]# mkdir /var/www/tedu /var/www/qq
[root@pc207 /]# echo '<h1>tedu'  > /var/www/tedu/index.html 
[root@pc207 /]# echo '<h1>QQ' > /var/www/qq/index.html
[root@pc207 /]# systemctl restart httpd

虚拟机A:
1.修改地址库文件记录
[root@svr7 ~]# vim /var/named/tedu.cn.zone
tedu.cn.  NS   svr7
svr7      A    192.168.4.7
www       A    192.168.4.207

[root@svr7 ~]# vim /var/named/qq.com.zone 
qq.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.207
[root@svr7 ~]# !sys
systemctl restart named
[root@svr7 ~]# 

虚拟机C:测试
1.指定DNS服务器地址
]# echo nameserver 192.168.4.7 > /etc/resolv.conf 
]# nslookup www.qq.com
]# nslookup www.tedu.cn

2.测试访问Web页面
]# firefox www.qq.com
]# firefox www.tedu.cn

##########################################
Services04                              #
########################################
Split分离解析(视图解析)
• 当收到客户机的DNS查询请求的时候
– 能够区分客户机的来源地址
– 为不同类别的客户机提供不同的解析结果(IP地址)
– 为不同的客户端,提供最近的解析结果

案例需求及要点
• 环境及需求
– 权威DNS:svr7.tedu.cn 192.168.4.7
– 负责区域:tedu.cn
– A记录分离解析 —— 以 www.tedu.cn 为例
客户机来自 解析结果
	192.168.4.207  ---www.tedu.cn----> 192.168.4.100
	其他地址 ---www.tedu.cn----->  1.2.3.4

分离解析配置:
1.客户端匹配原则为,由上到下,匹配即停止
2.每一个客户端都必须找到自己的分类
3.所有的zone都必须在view中
虚拟机A:
1.修改主配置文件
options {
        directory       "/var/named";
};
 view "nsd" {
  match-clients {  192.168.4.207;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";---->写入解析结果192.168.4.100
  };
 };
 view "other" {
  match-clients {  any;  };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";---->写入解析结果1.2.3.4
   };
 };
2.建立不同地址库文件
####################################################
多区域的分离解析

客户机来自 解析结果
	192.168.4.207  -------> 192.168.4.100
	其他地址 -------->  1.2.3.4


1.每一个view中zone的个数,以及zone负责的域名均要一致
view "nsd" {
 match-clients {  192.168.4.207;  };
 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.zone";
  };
};
view "other" {
 match-clients {  any;  };
 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.other";
  };
};

###################################################
了解内容:
  acl地址列表                                                

acl test {  192.168.4.207;  192.168.4.1;  192.168.7.0/24; 192.168.4.2; 192.168.4.27; };

view "nsd" {
 match-clients {  test;  };
 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.zone";
  };
};
####################################################
RAID磁盘阵列

• 廉价冗余磁盘阵列
– Redundant Arrays of Inexpensive Disks
– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘
– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同

• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率
– 至少由两块磁盘组成

• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少由两块磁盘组成

• RAID5,高性价比模式
– 相当于RAID0和RAID1的折中方案
– 需要至少一块磁盘的容量来存放校验数据
– 至少由三块磁盘组成

• RAID6,高性价比/可靠模式
– 相当于扩展的RAID5阵列,提供2份独立校验方案
– 需要至少两块磁盘的容量来存放校验数据
– 至少由四块磁盘组成

• RAID 0+1/RAID 1+0
– 整合RAID 0、RAID 1的优势
– 并行存取提高效率、镜像写入提高可靠性
– 至少由四块磁盘组成

####################################################
进程管理

   程序:静态的代码  占用磁盘空间
 
   进程:动态执行的代码  占用CPU  内存

   父进程与子进程   结构:树型结构

   僵尸进程     孤儿进程

  PID:进程的编号
  
查看进程树
• pstree — Processes Tree
– 格式:pstree [选项] [PID或用户名]

  systemd:上帝进程,所有进程的父进程
   
[root@svr7 /]# pstree
• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号

[root@svr7 ~]# pstree lisi     #查看lisi用户开启的进程
bash───vim
[root@svr7 ~]# pstree -p lisi
bash(3394)───vim(3419)
[root@svr7 ~]# pstree -ap lisi
bash,3394
  └─vim,3419 a.txt
[root@svr7 ~]# 


• ps aux 操作
– 列出正在运行的所有进程,信息非常全面

用户 进程ID %CPU %内存 虚拟内存 固定内存 终端 状态 起始时间 CPU时间 程序指令

• ps -elf 操作
– 列出正在运行的所有进程,可以显示该进程的父进程的PID

  PPID:父进程的PID号

请计算当前系统中运行的进程个数?
]# wc -l /etc/passwd
]# ps aux | wc -l

]# find /etc/ -name '*tab' -type f 
]# find /etc/ -name '*tab' -type f   | wc -l

]# find /etc/ -name '*.conf' -type f 
]# find /etc/ -name '*.conf' -type f     |  wc -l


###################################################

进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]

[root@svr7 ~]# top -d 1
     P(大写)进行CPU排序
     M(大写)进行内存排序

###################################################
检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件            
• 常用命令选项
– -l:输出进程名,而不仅仅是 PID
– -U:检索指定用户的进程
– -x:精确匹配完整的进程名
[root@svr7 ~]# pgrep -l a
[root@svr7 ~]# pgrep -l log

[root@svr7 ~]# pgrep -U lisi  
[root@svr7 ~]# pgrep -lU lisi
[root@svr7 ~]# pstree -ap lisi

################################################
进程的前后台调度

• 后台启动
– 在命令行末尾添加“&”符号,不占用当前终端
• Ctrl + z 组合键
– 挂起当前进程(暂停并转入后台)

• jobs 命令
– 查看后台任务列表
• fg 命令
– 将后台任务恢复到前台运行
• bg 命令
– 激活后台被挂起的任务

[root@svr7 ~]# sleep 1000 &     #将进程正在运行放入后台
[root@svr7 ~]# jobs             #查看后台进程信息
[root@svr7 ~]# sleep 800
^Z                             #按Ctrl+z 暂停放入后台
[2]+  已停止               sleep 800
[root@svr7 ~]# jobs 

[root@svr7 ~]# bg 2    #将后台编号为2的进程,继续运行
[root@svr7 ~]# jobs 
[root@svr7 ~]# fg 1    #将后台编号为1的进程,恢复到前台运行
sleep 1000
^C                     #按Ctrl+c结束     
[root@svr7 ~]# jobs
[root@svr7 ~]# fg 2    #将后台编号为2的进程,恢复到前台运行
sleep 800
^C                     #按Ctrl+c结束  
###################################################

• 干掉进程的不同方法
– Ctrl+c 组合键,中断当前命令程序
– kill [-9] PID... 、kill [-9] %后台任务编号
– killall [-9] 进程名...
– pkill 查找条件

[root@svr7 ~]# sleep 100 &
[root@svr7 ~]# sleep 200 &
[root@svr7 ~]# sleep 300 &

[root@svr7 ~]# jobs -l
[root@svr7 ~]# kill 3573
[root@svr7 ~]# jobs 

[root@svr7 ~]# killall sleep
[root@svr7 ~]# jobs 

[root@svr7 ~]# sleep 400 &
[root@svr7 ~]# jobs 
[root@svr7 ~]# killall -9 sleep   #强制杀
[root@svr7 ~]# jobs 

 强制踢出一个用户(杀死一个用户开启的所有进程)

[root@svr7 ~]# killall -9 -u lisi

#################################################
日志管理

日志的功能
• 系统和程序的“日记本”
– 记录系统、程序运行中发生的各种事件
– 通过查看日志,了解及排除故障
– 信息安全控制的  依据

• 由系统服务rsyslog统一记录/管理
 
• 常见的日志文件
	/var/log/messages 记录内核消息、各种服务的公共消息
	/var/log/dmesg 	记录系统启动过程的各种消息
	/var/log/cron 	记录与cron计划任务相关的消息
	/var/log/maillog 	记录邮件收发相关的消息
	/var/log/secure 	记录与访问限制相关的安全消息

日志分析

• 通用分析工具
– tail、tailf、less、grep等文本浏览/检索命令
– awk、sed等格式化过滤工具

 tailf:实时跟踪日志消息
[root@svr7 ~]# echo 123 > /opt/1.txt
[root@svr7 ~]# cat /opt/1.txt
123
[root@svr7 ~]# tailf  /opt/1.txt
123
haha

• users、who、w 命令
– 查看已登录的用户信息,详细度不同

    pts/0:图形终端

• last、lastb 命令
– 查看最近登录成功/失败的用户信息
[root@svr7 ~]# users
[root@svr7 ~]# who
[root@svr7 ~]# w

[root@svr7 ~]# last -2    #最近登录成功的用户记录
[root@svr7 ~]# lastb -2   #最近登录失败的用户记录

################################################
日志消息的优先级
• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）          会导致主机系统不可用的情况
  1  ALERT（警告）          必须马上采取措施解决的问题
  2  CRIT（严重）	        比较严重的情况
  3  ERR（错误）	       运行出现错误
  4  WARNING（提醒）      可能会影响系统功能的事件
  5  NOTICE（注意）        不会影响系统但值得注意
  6  INFO（信息）	       一般信息
  7  DEBUG（调试）          程序或系统调试信息等

##################################################
使用journalctl工具
• 提取由 systemd-journal 服务搜集的日志
– 主要包括内核/系统日志、服务日志

• 常见用法
– journalctl | grep 关键词
– journalctl -u 服务名   [-p 优先级]
– journalctl -n 消息条数
– journalctl --since="yyyy-mm-dd HH:MM:SS" --
until="yyyy-mm-dd HH:MM:SS"

[root@svr7 ~]# journalctl -u httpd
[root@svr7 ~]# journalctl -xe
###############################################
systemctl控制

• Linux系统和服务管理器
– 是内核引导之后加载的第一个初始化进程(PID=1)
– 负责掌控整个Linux的运行/服务资源组合


systemd
• 一个更高效的系统&服务管理器
– 开机服务并行启动,各系统服务间的精确依赖

– 配置目录:/etc/systemd/system/
– 服务目录:/lib/systemd/system/
– 主要管理工具:systemctl


对于服务的管理
 systemctl restart  服务名    #重起服务
 systemctl start    服务名    #开启服务
 systemctl stop     服务名    #停止服务
 systemctl status   服务名    #查看服务当前的状态
 
 systemctl enable   服务名      #设置服务开机自启动
 systemctl disable  服务名      #设置服务不开机自启动


RHEL6 运行级别    
  
         0：关机    
         1：单用户模式（基本功能的实现，破解Linux密码）
	 2：多用户字符界面（不支持网络）    
	 3：多用户字符界面（支持网络）服务器默认的运行级别   
	 4：未定义
	 5：图形界面   
	 6：重起 
   
    切换运行级别：init  5  



RHEL7 运行模式 

   字符模式：multi-user.target
   图形模式：graphical.target

[student@room9pc01 ~]$ rht-vmctl reset classroom
classroom [OK]
域 classroom 已开始

[student@room9pc01 ~]$ rht-vmctl reset server
server [OK]
域 server 已开始





[root@svr7 /]# ls -l /lib/systemd/system/

当前直接切换到字符模式
[root@svr7 /]# systemctl isolate multi-user.target
当前直接切换到图形模式
[root@svr7 /]# systemctl isolate graphical.target

查看每次开机默认进入模式
[root@svr7 /]# systemctl get-default
graphical.target

设置永久策略，每次开机自动进入graphical.target
# systemctl set-default multi-user.target
# reboot 


##########################################
Services05                              #
########################################
综合实验:
1.构建虚拟机C与虚拟机D的Web服务器
虚拟机C:
[root@svr10 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
  ServerName www.163.com
  DocumentRoot /var/www/163
</VirtualHost>
[root@svr10 ~]# mkdir /var/www/qq /var/www/163
[root@svr10 ~]# echo '<h1>Web1 QQ' > /var/www/qq/index.html
[root@svr10 ~]# echo '<h1>Web1 163' > /var/www/163/index.html

虚拟机D
[root@svr10 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
  ServerName www.qq.com
  DocumentRoot /var/www/qq
</VirtualHost>
<VirtualHost *:80>
  ServerName www.163.com
  DocumentRoot /var/www/163
</VirtualHost>
[root@svr10 ~]# mkdir /var/www/qq /var/www/163
[root@svr10 ~]# echo '<h1>Web2 QQ' > /var/www/qq/index.html
[root@svr10 ~]# echo '<h1>Web2 163' > /var/www/163/index.html

2.虚拟机A构建DNS服务器
[root@svr7 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";
};

view "nsd" {
 match-clients {  192.168.4.7;  };
 zone "163.com" IN {
        type master;
        file "163.com.zone";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.zone";
  };
};
view "other" {
 match-clients {  any;  };
 zone "163.com" IN {
        type master;
        file "163.com.other";
  };
 zone "qq.com" IN {
        type master;
        file "qq.com.other";
  };
};
   
[root@svr7 ~]# cd /var/named/
[root@svr7 named]# vim qq.com.zone 
qq.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.10

[root@svr7 named]# vim qq.com.other 
qq.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.20

[root@svr7 named]# cp -p qq.com.zone 163.com.zone
[root@svr7 named]# vim 163.com.zone
163.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.10

[root@svr7 named]# cp -p 163.com.zone 163.com.other
[root@svr7 named]# vim 163.com.other
163.com.    NS   svr7
svr7       A    192.168.4.7
www        A    192.168.4.20
[root@svr7 /]# systemctl restart named

3.指定DNS服务器地址

[root@svr7 /]# echo 'nameserver 192.168.4.7'  > /etc/resolv.conf

[root@pc207 ~]# echo 'nameserver 192.168.4.7'  > /etc/resolv.conf

[root@svr10 ~]# echo 'nameserver 192.168.4.7'  > /etc/resolv.conf

[root@pc20 ~]# echo 'nameserver 192.168.4.7'  > /etc/resolv.conf

###################################################
部署DHCP服务器
• Dynamic Host Configuration Protocol
– 动态主机配置协议,由 IETF(Internet 网络工程师任
务小组)组织制定,用来简化主机地址分配管理

• 主要分配以下入网参数
– IP地址/子网掩码/广播地址
– 默认网关地址、DNS服务器地址

• DHCP地址分配的四次会话(以广播形式进行,先到先得)
– DISCOVERY --> OFFER --> REQUEST -->ACK

   在一个网络中,只能有一个DHCP服务器

• 服务端基本概念
– 租期:允许客户机租用IP地址的时间期限,单位为秒
– 作用域:分配给客户机的IP地址所在的网段
– 地址池:用来动态分配的IP地址的范围


虚拟机A:
1.安装dhcp软件包
[root@svr7 ~]# yum -y install dhcp
2.修改配置文件
[root@svr7 ~]# vim /etc/dhcp/dhcpd.conf     
末行模式下:
   :r /usr/share/doc/dhcp*/dhcpd.conf.example

subnet 192.168.4.0 netmask 255.255.255.0 {  #分配的网段
  range 192.168.4.100  192.168.4.200;     #分配的IP范围
  option domain-name-servers 192.168.4.7;  #分配DNS地址
  option routers 192.168.4.254;  #分配网关地址
  default-lease-time 600;
  max-lease-time 7200;
} 

3.重启dhcpd服务
[root@svr7 ~]# systemctl  restart dhcpd

###################################################
网络装机概述

网络装机的优势
• 规模化:同时装配多台主机
• 自动化:装系统、配置各种服务
• 远程实现:不需要光盘、U盘等物理安装介质

什么是PXE网络
• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装

• 工作模式
– PXE client 集成在网卡的启动芯片中
– 当计算机引导时,从网卡芯片中把PXE client调入内存
执行,获取PXE server配置、显示菜单,根据用户选
择将远程引导程序下载到本机运行

•服务端需要哪些服务组件
 – DHCP服务,分配IP地址、定位引导程序
 – TFTP服务,提供引导程序下载
 – HTTP服务,提供yum安装源


###################################################
在虚拟机A构建PXE网络装机服务器
一  配置DHCP服务器,指定下一个服务器地址
[root@svr7 ~]# vim /etc/dhcp/dhcpd.conf 
subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.100  192.168.4.200;
  option domain-name-servers 192.168.4.7;
  option routers 192.168.4.254;
  default-lease-time 600;
  max-lease-time 7200;
  next-server  192.168.4.7;   #指定下一个服务器地址
  filename  "pxelinux.0";    #指定网卡引导文件名称
}

[root@svr7 ~]# systemctl restart dhcpd

 pxelinux.0:网卡引导文件 ,安装说明书,二进制文件
                      安装一个软件即可获得,默认生成的名字pxelinux.0

####################################################
二 构建tftp服务

  tftp:简单的文件传输协议                           
    端口默认为:69
    默认共享位置:/var/lib/tftpboot

1.安装软件包为tftp-server
[root@svr7 ~]# yum -y install tftp-server
2.重启服务
[root@svr7 ~]# systemctl restart tftp

3.部署pxelinux.0引导文件
]# yum  provides  */pxelinux.0  #查询那个包产生的该文件
]# yum -y install syslinux           
]# rpm -ql syslinux  | grep pxelinux.0  #查询软件包安装清单

]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/
]# ls /var/lib/tftpboot/

客户端----->DHCP---->next-server--->pxelinux.0
pxelinux.0---->/var/lib/tftpboot/pxelinux.cfg/default

4.部署默认菜单文件
首先关闭虚拟机A,图形添加一个光驱设备,放入光盘文件
[root@svr7 ~]# ls /dev/cdrom 
[root@svr7 ~]# mount /dev/cdrom  /mnt/
[root@svr7 ~]# ls /mnt/

]# mkdir /var/lib/tftpboot/pxelinux.cfg
]# cp /mnt/isolinux/isolinux.cfg  /var/lib/tftpboot/pxelinux.cfg/default

]# ls -l /var/lib/tftpboot/pxelinux.cfg/default


5.部署图形模块(vesamenu.c32)和背景图片(splash.png)
]# cp /mnt/isolinux/vesamenu.c32  /mnt/isolinux/splash.png  /var/lib/tftpboot/

]# ls /var/lib/tftpboot/
pxelinux.0  pxelinux.cfg  splash.png  vesamenu.c32

6.部署启动内核(vmlinuz)和驱动程序(initrd.img)
]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img /var/lib/tftpboot/

]# ls /var/lib/tftpboot/
initrd.img  pxelinux.cfg  vesamenu.c32
pxelinux.0  splash.png    vmlinuz

##################################################
总结:
 dhcp--->IP地址   next-server  filename
 tftp--->pxelinux.0
 pxelinux.0--->读取default菜单文件
 default--->vesamenu.c32 splash.png  vmlinuz  initrd.img

7.修改菜单文件内容
]# vim  /var/lib/tftpboot/pxelinux.cfg/default
末行模式 :set  nu
   1 default vesamenu.c32  #默认加载运行图形的模块
   2 timeout 600           #默认读秒时间  1/10秒

   10 menu background splash.png     #背景图片
   11 menu title NSD1904 PXE Server  #显示标题信息

  61 label linux
  62   menu label  Install CentOS7.5  #屏幕显示信息
  63   menu default                   #读秒结束后默认选项
  63   kernel vmlinuz                 #指定启动内核
  64   append initrd=initrd.img       #指定驱动程序
##################################################
[root@svr7 ~]# systemctl restart dhcpd
[root@svr7 ~]# systemctl restart tftp
##################################################
初步测试:
   新建一台全新的虚拟机
   1.安装方式选择:PXE网络引导安装
   2.内存必须2G   
   3.网络类型选择:private1

总结:
 dhcp--->IP地址   next-server  filename
 tftp--->pxelinux.0
 pxelinux.0--->读取default菜单文件
 default--->vesamenu.c32 splash.png  vmlinuz  initrd.img

#################################################
三 构建Web服务器,将光盘内容共享给客户端              
1.安装软件包
[root@svr7 ~]# yum -y install httpd

[root@svr7 ~]# mkdir /var/www/html/centos
[root@svr7 ~]# ls /var/www/html/centos

[root@svr7 ~]# mount /dev/cdrom  /var/www/html/centos
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 ~]# ls /var/www/html/centos
[root@svr7 ~]# systemctl restart httpd

[root@svr7 ~]# firefox http://192.168.4.7/centos

##################################################
四 部署无人值守安装,生成应答文件

1.安装一个system-config-kickstart图形化软件,生成应答文件
[root@svr7 ~]# yum -y install system-config-kickstart 

2.运行图形化工具
以英文语言进行运行
[root@svr7 ~]# LANG=en  system-config-kickstart
  
 点击 "软件包选择(Package Selection)" 查看是否可以进行选择
 需要Yum仓库的支持:指向光盘的内容仓库,标识必须为 [development]
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo 
[development]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[root@svr7 ~]# LANG=en  system-config-kickstart
 点击 "软件包选择(Package Selection)" 查看是否可以进行选择

[root@svr7 ~]# ls /root/ks.cfg           
/root/ks.cfg

[root@svr7 ~]# vim /root/ks.cfg

3.利用Web服务器共享应答文件
[root@svr7 ~]# cp /root/ks.cfg /var/www/html/
[root@svr7 ~]# ls /var/www/html/
centos  ks.cfg
[root@svr7 ~]# firefox http://192.168.4.7/ks.cfg

4.通过菜单文件,指定ks应答文件获取方式
]# vim /var/lib/tftpboot/pxelinux.cfg/default 
label linux
 menu label  Install CentOS7.5
 menu default
 kernel vmlinuz
 append initrd=initrd.img ks=http://192.168.4.7/ks.cfg

]# 
##################################################
总结:
 dhcp--->IP地址   next-server  filename
 tftp--->pxelinux.0
 pxelinux.0--->读取default菜单文件
 default--->图形模块  背景  内核  驱动   ks应答文件
 ks应答文件--->语言  分区  密码  时区 ...  指定获取软件包的方式
  获取软件包的方式---> --url="http://192.168.4.7/centos"

##########################################
Services06                              #
########################################
总结:
 dhcp--->IP地址   next-server  filename
 tftp--->pxelinux.0
 pxelinux.0--->读取default菜单文件
 default--->图形模块  背景  内核  驱动   ks应答文件
 ks应答文件--->语言  分区  密码  时区 ...  指定获取软件包的方式
  获取软件包的方式---> --url="http://192.168.4.7/centos"
###################################################
rsync同步操作

rsync同步操作
• 命令用法
– rsync [选项...]   源目录     目标目录

• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据

同步控制
• rsync操作选项
– -n:测试同步过程,不做实际修改
– --delete:删除目标文件夹内多余的文档
– -a:归档模式,相当于-rlptgoD
– -v:显示详细操作信息
– -z:传输过程中启用压缩/解压


[root@svr7 ~]# mkdir   /dir01     /abc
[root@svr7 ~]# cp /etc/passwd /etc/fstab  /dir01
[root@svr7 ~]# ls /dir01

[root@svr7 ~]# rsync -avz   /dir01    /abc/  #同步目录本身
[root@svr7 ~]# ls /abc
[root@svr7 ~]# ls /abc/dir01/

[root@svr7 ~]# rsync -avz /dir01/   /abc/  #同步目录内容
[root@svr7 ~]# ls /abc/

[root@svr7 ~]# touch /dir01/1.txt
[root@svr7 ~]# ls /dir01/
[root@svr7 ~]# rsync -avz /dir01/   /abc/
[root@svr7 ~]# ls /abc/


[root@svr7 ~]# ls /dir01/
[root@svr7 ~]# ls /abc/
[root@svr7 ~]# touch /abc/haha.txt
[root@svr7 ~]# ls /abc/

[root@svr7 ~]# rsync -avz --delete  /dir01/  /abc/
[root@svr7 ~]# ls /abc/

[root@svr7 ~]# touch /abc/{1..5}.txt
[root@svr7 ~]# ls /abc/
[root@svr7 ~]# rsync -avz --delete  /dir01/  /abc/
[root@svr7 ~]# ls /abc/

###################################################
rsync+SSH同步

• 与远程的 SSH目录保持同步
– 下行:rsync [...]  user@host:远程目录      本地目录

– 上行:rsync [...]  本地目录   user@host:远程目录



虚拟机A:	
[root@svr7 ~]# rsync -avz --delete  /dir01/    root@192.168.4.207:/opt/

虚拟机B:
[root@pc207 ~]# ls /opt/

###################################################
虚拟机A:	
[root@svr7 ~]# touch /dir01/xixi.txt
[root@svr7 ~]# rsync -avz --delete  /dir01/ root@192.168.4.207:/opt/

虚拟机B:
[root@pc207 ~]# ls /opt

###################################################
实时同步

虚拟机A
一  生成公钥与私钥,实现ssh无密码验证
[root@svr7 ~]# ssh-keygen     #一路回车
[root@svr7 ~]# ls /root/.ssh/
authorized_keys(别的机器传递过来的公钥)  id_rsa(私钥)  id_rsa.pub(公钥) 

[root@svr7 ~]# ssh-copy-id root@192.168.4.207

[root@svr7 ~]# rsync -avz --delete  /dir01/ root@192.168.4.207:/opt/


二  监控目录内容的变化

安装inotify-tools工具                                         
真机上:
[student@room9pc01 ~]$ ls /linux-soft/01/
Cobbler.zip  tools.tar.gz
[student@room9pc01 ~]$ scp /linux-soft/01/tools.tar.gz    root@192.168.4.7:/root

1.让虚拟机A具备inotify-tools-3.13.tar.gz
[root@svr7 /]# ls /root/
[root@svr7 /]# mkdir /test
[root@svr7 /]# tar -xf /root/tools.tar.gz -C /test
[root@svr7 /]# ls /test
[root@svr7 /]# ls /test/tools/

步骤1:安装依赖关系包(安装开发工具)
]# yum -y install  gcc  make
步骤2:tar解包,释放源代码至指定目录
]# tar -xf /test/tools/inotify-tools-3.13.tar.gz -C /opt
]# ls /opt
]# cd /opt/inotify-tools-3.13/
]# ls
步骤3: ./configure 配置,指定安装目录/功能模块等选项
]# cd /opt/inotify-tools-3.13/
]# ./configure 
步骤4:make 编译,生成可执行的二进制程序文件
]# make
步骤5:make install 安装,将编译好的文件复制到安装目录
]# make install
]# ls /usr/local/bin/inotifywait 


inotifywait监控
• 基本用法
– inotifywait  [选项]  目标文件夹

• 常用命令选项
– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的 modify、move、create、delete、attrib等事件类别

三  书写Shell脚本

    for循环:适合有规定次数的循环
    while适合死循环:次数无限及无法确定

        while  [条件]
        do
                重复执行操作
        done

[root@svr7 /]# vim /opt/rsync.sh
#!/bin/bash
while  inotifywait  -rqq  /dir01 
do
 rsync -az --delete  /dir01/  root@192.168.4.207:/opt/
done

[root@svr7 /]# chmod +x /opt/rsync.sh

[root@svr7 /]# /opt/rsync.sh

#############################
Cobbler装机平台,不同版本的多系统的安装

教学环境虚拟机3.1版本进行扩容
[root@svr7 ~]# df -h
文件系统        容量  已用  可用 已用% 挂载点
/dev/vda1       2.0G  1.8G  256M   88% /

[root@svr7 ~]# LANG=en growpart /dev/vda 1
[root@svr7 ~]# df -h
[root@svr7 ~]# xfs_growfs /dev/vda1

[root@svr7 ~]# df -h
文件系统        容量  已用  可用 已用% 挂载点
/dev/vda1        20G  1.8G   19G    9% /


一  具备一个CentOS虚拟机  
[root@svr7 ~]# cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core) 
                                     
二、虚拟机设置  
   1.设置防火墙为trusted
  ]# firewall-cmd  --set-default-zone=trusted 

   2.当前及永久设置SELinux状态为permissive
  ]# setenforce 0     #当前临时关闭
  ]# getenforce 
  ]# vim /etc/selinux/config 
  SELINUX=	


##################################################
[root@svr7 ~]# LANG=en growpart  /dev/vda   1  
[root@svr7 ~]# df -h
[root@svr7 ~]# xfs_growfs /dev/vda1
##################################################

三、利用scp真机传递cobbler.zip包到虚拟机192.168.4.7中
 # scp /home/student/桌面/cobbler.zip   root@192.168.4.7:/root/
 

##################################################

四、搭建Cobbler装机平台

  Cobbler概述软件，管理dhcp、tftp、Web服务
    自由的导入镜像与ks应答文件

1.解压cobbler.zip包
[root@svr7 ~]# yum -y install unzip 

[root@svr7 ~]# unzip /root/cobbler.zip -d /
[root@svr7 ~]# ls /cobbler/
cobbler_boot.tar.gz  cobbler_web.png
cobbler_rpm.zip
[root@svr7 ~]# 

[root@svr7 ~]# unzip /cobbler/cobbler_rpm.zip -d /opt/
[root@svr7 ~]# ls /opt/cobbler/

#####################################################
五、安装cobbler主程序、工具包等
]# yum -y install  dhcp  httpd  mod_ssl 

]# yum -y install  /opt/cobbler/*.rpm  

[root@svr7 ~]# rpm -q cobbler
cobbler-2.8.2-1.el7.x86_64
[root@svr7 ~]# 

################################################################
cobbler网络装机部署

1.安装软件 cobbler cobbler-web dhcp tftp-server pykickstart httpd  tftp-server 

 cobbler         #cobbler程序包
 cobbler-web     #cobbler的web服务包
 pykickstart     #cobbler检查kickstart语法错误
 httpd           #Apache web服务
 dhcp            #dhcp服务
 tftp-server     #tftp服务




2.配置cobbler
[root@svr7 /]# vim  /etc/cobbler/settings

 next_server:   192.168.4.7    #设置下一个服务器还为本机
 server:   192.168.4.7         #设置本机为cobbler服务器
 manage_dhcp:   1              #设置cobbler管理dhcp服务
 pxe_just_once:   1            #防止客户端重复安装操作系统

 开机启动项： 匹配及停止  
     1.硬盘启动     2.光驱设备     3.U盘     4.网络引导  


3.配置cobbler的dhcp
[root@svr7 /]# vim  /etc/cobbler/dhcp.template 

  :%s  /旧/新/g      #全文替换
  :%s  /192.168.1/192.168.4/g    #全文替换

    5 次替换，共 4 行   


4.绝对路径解压cobbler_boot.tar.gz    #众多的引导文件
# tar -tf  /cobbler/cobbler_boot.tar.gz   #查看包里面内容
# tar -xPf  /cobbler/cobbler_boot.tar.gz  #绝对路径释放
# ls  /var/lib/cobbler/loaders/

5.启动相关服务
  ]# systemctl restart cobblerd     
  ]# systemctl enable cobblerd

  ]# systemctl restart httpd
  ]# systemctl enable httpd

  ]# systemctl restart tftp
  ]# systemctl enable tftp

  ]# systemctl restart rsyncd   #同步服务
  ]# systemctl enable rsyncd

6.同步刷新cobbler配置
[root@svr7 /]# cobbler sync    #检测所有配置是否正确
......
*** TASK COMPLETE ***


]# firefox https://192.168.4.7/cobbler_web

   用户名：cobbler
   密码：cobbler                                         
 



##########################################################################################################
cobbler应用

  cobbler import  --path=挂载点   --name=导入系统命名（随意起）
导入安装镜像数据
# mkdir /dvd
# mount /dev/cdrom  /dvd
# ls /dvd/

# cobbler import --path=/dvd  --name=CentOS7

cobbler导入的镜像放在：/var/www/cobbler/ks_mirror


[root@cobbler /]# cobbler list    #查看有哪些系统
distros:
   CentOS7-x86_64        #安装客户端至少2G内存

profiles:
   CentOS7-x86_64

##############################################
删除
# cobbler list 
# cobbler profile remove --name=CentOS7-x86_64  #删除菜单信息
# cobbler distro remove --name=CentOS7-x86_64  #删除镜像信息


###########################################

# umount /dvd/
# mount /dev/cdrom  /dvd   将光盘换成RHEL7
# ls /dvd/

  安装完成机器 默认root  密码  cobbler

############################################################################################################
自定义应答文件：开头注释行删除

[root@cobbler ~]# system-config-kickstart  #生成ks文件

必须默认kickstart文件存放位置：/var/lib/cobbler/kickstarts/

[root@cobbler ~]# cobbler list

修改kickstart文件：
[root@cobbler ~]# cobbler profile edit --name=CentOS7  --kickstart=/var/lib/cobbler/kickstarts/自定义.cfg

[root@cobbler ~]# cobbler profile report
[root@cobbler ~]# cobbler sync  #同步配置

##########################################
network day 01                          #
########################################
网络的功能:
1,数据通讯
2,资源共享
3,提高可靠
4,提高系统处理能力

网络历史
60年代,分组交换,可以提高数据传输成功率,降低服务器负担
70~80,TCP/IP
90~至今,web技术

iso 国际标准化组织
ieee 电子与电气工程师学会

WAN  几十公里     internet
LAN  1公里以内   办公室,教室,宿舍

企业级
思科  华为
路由器 交换机

拓扑结构:
1,点对点 , 适用范围是广域网
2,星形,适用范围是局域网,优点是容易扩展,易实现,易于故障排查
3,网状,适用范围是局域网,高可靠

osi七层参考模型(理论框架)
物理层,数据链路层,网络层,传输层,会话层,表示层,应用层
tcp\ip五层模型(实际使用)
物理层,数据链路层,网络层,传输层,应用层
 网卡    交换机   路由器  防火墙  PC

PDU协议数据单元:(不同层次数据在传输时用的单位)
物理层--比特流
数据链路层--数据帧
网络层--数据包
传输层--数据段

进入win2008系统
密码:tedu
==========================
运行脚本,教学环境需要:
172.40.50.115
pub目录下找kvm.sh
1,要用root执行(需要添加执行权限)
2,关闭所有虚拟机
成功后看到ok字样
==========================

网络设备命令行视图
1, 用户视图   >  system-view 
    系统视图 ]
    接口视图 g0/0/1]
    协议视图

quit   //返回上一视图
return 或者 快捷键ctrl +z  //返回到用户视图

模块 / 子卡/接口号

<Huawei>system-view             //进入系统视图
[Huawei]interface GigabitEthernet0/0/1    //进入接口视图
[Huawei-GigabitEthernet0/0/1]quit    //返回上一视图
[Huawei]
[Huawei]interface GigabitEthernet0/0/1    //再次进入接口视图
[Huawei-GigabitEthernet0/0/1]return     //返回用户视图
<Huawei>

修改主机名
[Huawei]sysname SW1    //在系统视图下将名字修改为SW1
[Huawei]display current-configuration  //查看当前配置
[Huawei]display this   //查看当前视图配置
[Huawei]display version   //查看系统版本,硬件型号等信息

配置用户名和密码:
<Huawei>system-view 
[Huawei]aaa          //进入aaa认证,此视图支持用户的创建
[Huawei-aaa]local-user admin01 password cipher 123    //创建账户叫admin01,密码123       
[Huawei-aaa]quit
[Huawei]user-interface console 0     //进入控制台接口视图   
[Huawei-ui-console0]authentication-mode aaa    //激活配置
然后使用快捷键 ctrl + ]   //退出系统,测试账户密码的配置

<Huawei>save    //保存配置,途中按y
<Huawei>reboot   //重启,途中按y

ip地址,相当于住址
MAC地址  (硬件地址  物理地址) ,相当于身份证号,全球唯一,不可更改

bit 比特(位) 二进制   0  1

0 1 

1+1     10

0123456789     10 
0123456789ABCDEF    10

十六进制
52:54:00:35:6e:56
5254:0035:6e56
52-54-00-35-6e-56

1对1       单播通讯
1对多      组播通讯
1对所有   广播通讯

MTU  最大传输单元,通常是1500字节

MAC地址长度48位,前24位记录了厂商标识,后24位记录了产品序号

交换机: 组建局域网的基本设备,可以智能的通过数据帧中的MAC地址
进行数据传递,因此交换机工作在数据链路层.

交换机工作原理
1,学习,学习源mac地址
2,广播,对除了数据来源的所有接口发送广播信息
3,转发,1对1通讯
4,更新,超过300秒无任何数据通讯,交换机会清除对应的mac地址记录
	   交换机接口设备关机或更换将会立刻删除对应mac地址记录

[Huawei]display mac-address    //查看mac地址表
[Huawei]in e0/0/1    //进入e0/0/1接口
[Huawei-ethernet0/0/1]shutdown   //关闭接口
[Huawei-ethernet0/0/1]undo shutdown   //打开接口

##########################################
network day 02                          #
########################################
网络功能, 资源共享 ,数据通讯,提高可靠,提高系统处理能力
60,分组交换
70~80 ,tcp/ip
90, web技术

iso 
osi
物理层 ,数据链路层,网络层,传输层 应用层
  网卡,     交换机,    路由器, 防火墙, PC
   比特流,  数据帧  ,  数据包,  数据段

拓扑结构
1,点对点 , 广域网
2,星形
3,网状

用户视图,系统视图,接口视图,协议视图  quit 
MAC,物理地址,硬件地址   
48位   前24位 厂商标识, 后24位厂商赋予的产品序号
交换机的工作原理
学习,广播,转发,更新

广播泛滥

vlan  虚拟局域网
1,控制广播
2,提高安全
3,提高带宽利用
4,降低数据传输延迟

4096个   0~4095    1000+ 

广播域, 相同广播域中的主机可以接收到来自本域的所有广播
1个广播域=1个部门=1个vlan=相同网段

vlan 2   //创建vlan 2
undo vlan 2   //删除vlan 2
vlan batch 2 6  //创建vlan2和vlan6
vlan batch 2 to 6  //创建vlan2,vlan3,vlan4,vlan5,vlan6
dispaly vlan   //查看vlan列表

in e0/0/3    //进入3接口
port link-type access    //接口类型修改为access
port default vlan 2      //将此接口加入vlan2
in e0/0/4    //进入4接口
port link-type access    //接口类型修改为access
port default vlan 2      //将此接口加入vlan2

或

[Huawei]port-group 1    //进入1号组
[Huawei-port-group-1]group-member Ethernet0/0/3 Ethernet0/0/4   //添加3接口与4接口到该组
[Huawei-port-group-1]port link-type access  //对全组接口修改类型
[Huawei-port-group-1]port default vlan 2 //将全组接口加入vlan2  

vlan3:
[Huawei]port-group 2    //进入2号组
[Huawei-port-group-2]group-member Ethernet0/0/5 Ethernet0/0/6   //添加5接口与6接口到该组
[Huawei-port-group-2]port link-type access  //对全组接口修改类型
[Huawei-port-group-2]port default vlan 3 //将全组接口加入vlan3 
最后使用 display vlan  查看配置

SW1
in e0/0/7
port link-type access    //接口类型修改为access
port default vlan 3      //将此接口加入vlan3

SW2
in e0/0/7
port link-type access    //接口类型修改为access
port default vlan 3      //将此接口加入vlan3
in e0/0/3
port link-type access    //接口类型修改为access
port default vlan 3      //将此接口加入vlan3

access 接入链路   承载1个vlan,通常在链接了终端设备(PC)的接口配置
trunk  中继链路   承载多个vlan,通常在两台交换机之间的链路配置

clear configuration interface Ethernet 0/0/7   //在系统视图,清空7接口所有配置,注意清空后接口自动关闭
in e0/0/7    //进入7接口
undo shutdown     //开启接口
port link-type trunk   //继续在7口中配置中继链路
port trunk allow-pass vlan all   //允许所有vlan通过
display this  //检查配置

配置思路:
1,规划vlan,需要多少创建多少
2,将对应的接口加入vlan
3,交换机之间的链路配置为trunk
最后pc配置好ip做ping测试

单点故障


链路聚合,提高链路可靠,提高链路带宽
注意:配置之前检查接口是否为默认状态,否则要清空配置
clear configuration interface Ethernet 0/0/7 
in e0/0/7
undo shutdown
1,找到要捆绑的接口,至少2个以上
2,创建链路聚合接口
interface Eth-trunk 1    //创建1号链路聚合接口
3,将物理接口加入链路聚合接口
trunkport ethernet 0/0/7  0/0/8   //将7口8口加入并捆绑在一起
port link-type trunk    //继续将1号链路聚合口配置为中继链路
port trunk allow-pass vlan all   //放行所有vlan

<Hhuawei>undo terminal monitor  //在用户视图下关闭某些信息提示
 
A 1~127   /8
255.0.0.0
B 128~191   /16
255.255.0.0
C 192~223     /24
255.255.255.0
192.168.0.1

172.25.0.10 /24     172.25.0.1~172.25.0.254
255.255.255.0

172.25.0.10 /16     172.25.0.1~172.25.255.254    172.25.0.255  172.25.1.0
255.255.0.0


c类地址可用范围,比如192.168.1.0网段 就是192.168.1.1~192.168.1.254

某网段中 第一个地址是网络ID,最后一个地址是广播地址

172.16.16.16    172.16.0.1~ 172.16.255.254
255.255.0.0

使用路由器链接不同网段
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/1]ip address 192.168.1.254 24
[Huawei-GigabitEthernet0/0/1]quit
[Huawei]interface GigabitEthernet 0/0/1
[Huawei-GigabitEthernet0/0/1]ip address 192.168.2.254 24

网关:终端设备访问其他网段的出口,通常网关由一台三层设备承担,比如路由器
PC1 的ip 192.168.1.1 /24 网关192.168.1.254
PC2 的ip 192.168.2.1 /24 网关192.168.2.254

路由器可以将不同网段的数据进行传递,依靠路由表来选路
路由表指明当前设备可以前往的区域(网段)

路由表中具体可以前往的目的地可以由以下方式获得
1,直连路由 : 在设备接口配置好ip地址并且打开后 自动产生
2,静态路由 : 由管理员手工设置,小规模网络使用
ip route-static 目标网络id 目标网络子网掩码  下一跳地址

R1
[Huawei]ip route-static 192.168.3.0 24 192.168.2.2    //管理员人工指定(增加)该设备可以前往的网段是3.0, 只要将目的地址是3.0的数据扔向2.2即可
[Huawei]ip route-static 192.168.4.0 24 192.168.2.2
R2
[Huawei]ip route-static 192.168.1.0 24 192.168.2.1

##########################################
network day 03                          #
########################################
三层交换机= 三层路由 + 二层交换

使用三层交换机
可以先关闭信息提示避免干扰
<Huawei>undo terminal monitor
1,创建所需vlan
[Huawei]vlan batch 2 3
2,将接口加入对应vlan
interface g0/0/2
port link-type access
port default vlan 2
interface g0/0/3
port link-type access
port default vlan 3
3,在三层交换机虚拟接口配置ip,作为终端设备的网关
三层交换机配置ip需要在vlan虚拟接口进行
in vlan 1
ip address 192.168.1.254 24
in vlan 2
ip address 192.168.2.254 24
in vlan 3
ip address 192.168.3.254 24

添加普通交换机合理利用三层交换机的接口
1,新添加S3700一台
2,在S3700中创建vlan2 ,vlan3
3,将e0/0/2接口加入vlan2,e0/0/3接口加入vlan3

在两台交换机之间的链路配置trunk并放行所有vlan
S3700
in e0/0/22
port link-type trunk
port trunk allow-pass vlan all
S5700
in g0/0/1
port link-type trunk
port trunk allow-pass vlan all

为S5700的g0/0/2接口赋予ip的方式:
vlan 4  //创建vlan4
in vlan 4    //进入vlan4的虚拟接口
ip address 192.168.4.1 24   //为此接口配ip
in g0/0/2    //进入2口
port link-type access   //设置类型
port default vlan 4   //加入vlan4

dis ip interface brief  //查看所有配置过的ip
dis vlan    //可以在接口后面看到U代表开启D代表关闭

路由 指路
路由设备依靠路由表来传输不同网段数据

1,直连路由,接口配置ip并开启,自动生成
2,静态路由
3,动态路由,是由某些动态路由协议实现,适合大型网络
4,默认路由,是特殊的静态路由,可以访问任意网络
		  通常配置在末梢网络或网关出口设备

ospf 开放最短路径优先
宣告,告知其他设备自身所连接的网段

S5700:
ospf    //进入ospf协议视图
area 0   //进入区域0,小规模网络只需要一个区域,且必须从0开始
network 192.168.1.0 0.0.0.255   //宣告所在网段
network 192.168.2.0 0.0.0.255
network 192.168.3.0 0.0.0.255
network 192.168.4.0 0.0.0.255

路由器:
ospf
area 0
network 192.168.5.0 0.0.0.255
network 192.168.4.0 0.0.0.255

使用默认路由访问外部网段
1,删除路由器5网段的宣告
ospf
area 0
undo network 192.168.5.0 0.0.0.255
2,在三层交换机中配置默认路由(0.0.0.0 0 代表任意网络)
ip route-static 0.0.0.0 0 192.168.4.2    

传输层,定义了端口号,实现了端到端的链接

端口总数65536个
范围0~65535
1~1023  知名端口号

TCP 可靠,效率低,面向连接
UDP 不可靠, 效率高,无连接

TCP协议中比较重要的三个标志位
ACK 确认
SYN 打算与对方建立连接
FIN 打算与对方断开链接

三次握手  syn---ack,syn---ack
四次断开  fin---ack---fin---ack

ACL  访问控制列表
高级ACL  3000~3999   源ip  目标ip 源端口  目标端口  协议
基本ACL  2000~2999   源ip
1,创建acl条目
2,在接口应用

255.255.255.0
11111111.11111111.11111111.00000000

192.168.2.100

192.168.2.1 0.0.0.0
0严格匹配
1(8个1就是255) 不匹配
deny    拒绝
permit  允许

使用acl实现禁止192.168.2.1与192.168.1.1通讯 
在路由器上配置:
[Huawei]acl 2000  //创建acl2000
[Huawei-acl-basic-2000]rule deny source 192.168.2.1 0   //定义规则,禁止源地址是192.168.2.1的数据通过
[Huawei]interface G0/0/1  //进入1接口
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000    //在接口使用acl2000过滤进入的数据

最后验证使用2.1无法与1.1互通,而2.2可以

只允许2.1与1.1通讯,其他主机无法连通1.1
acl 2001  //创建acl2001 
[Huawei-acl-basic-2001]rule permit source 192.168.2.1 0   //允许2.1通过
[Huawei-acl-basic-2001]rule deny source any  //禁止任何人通过
[Huawei]interface G0/0/1  //进入1接口
[Huawei-GigabitEthernet0/0/1]undo traffic-filter inbound   //在接口删除之前启用的acl
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2001  //在接口应用新的acl
*注意:acl条目讲究顺序,匹配即立场,上述实验acl的规则不能写反!
display acl 2001   //查看配置的acl

通过高级acl的配置,禁止2.1访问1.1的网站,其他业务不受影响
acl 3000
rule deny tcp source 192.168.2.1 0 destination 192.168.1.1 0 destination-port eq 80
interface G0/0/1  //进入1接口
undo traffic-filter inbound   //在接口删除之前启用的acl(如果已经删除了,不用再删除,使用display this验证即可)
traffic-filter inbound acl 3000  //在接口应用新的acl
最后使用2.1访问1.1,效果是能ping通,却访问不了网站

##########################################
network day 04                          #
########################################
交换机工作在数据链路层, 传输数据帧,可以智能的依靠MAC地址查找目的主机
路由器工作在网络层,传输数据包,依靠路由表完成数据转发
传输层可以实现端到端的数据传递
TCP 高可靠,效率低,面向连接
三次握手,四次断开
UDP 不可靠,效率高,无连接

ACL 基本 2000~2999 对源ip控制   deny permit
        高级 3000~3999 对源ip,目的ip,源端口,目的端口,协议
21 ftp tcp
22 ssh tcp
53 dns tcp/udp
80 http tcp
443 https tcp
69  tftp  udp
110 pop3 tcp
25  smtp tcp

nat  网络地址转换,可以将内部的私有ip地址与公有ip进行转换

A 1~127
B 128~191
C 192~223

私有ip地址范围
A 10.0.0.0~10.255.255.255
B 172.16.0.0~172.31.255.255
C 192.168.0.0~192.168.255.255

ipv4   42亿
100M  500~800  动态公网ip
100M  50000 静态公网ip      www.baidu.com  100.0.0.1
	    2000
ipv6   海量

配置方式
1,静态nat,一对一转换,一般用在服务器对外网发布服务时使用
2,easy ip,一对多转换,通常对只需要访问外网的设备配置
192.168.0.1 100.0.0.1 >                     < 100.0.0.2 192.168.0.1
路由器配置
in g0/0/0
ip add 192.168.2.254 24
in g0/0/1
ip add 100.0.0.1 8
进入外网接口配置nat:
nat static global 100.0.0.2 inside 192.168.2.1   //使用静态nat将外部地址100.0.0.2与内部地址192.168.2.1进行一对一绑定
nat static global 100.0.0.3 inside 192.168.2.2

静态nat使用1对1的方式,可以方便的让内外网互访,但成本较高
192.168.2.1 = 100.0.0.2  >         < 100.0.0.10
192.168.2.2 = 100.0.0.3  >         < 100.0.0.10
easy ip可以让内部多个私有地址通过一个公网ip出门,能最大程度节约公网ip,但如果先在外网向内网发送数据是无法通讯的.
192.168.2.1:2000= 100.0.0.1:2000  >         < 100.0.0.10         
192.168.2.2:2001 =100.0.0.1:2001  >         < 100.0.0.10     

使用easy ip让内部主机都通过一个外网的接口ip出门,可以达到节约公网ip的目的
acl 2000
rule permit source any     //使用acl定义任何内部地址 
进入路由器公网接口
nat outbound 2000    //让内部任何主机都可以利用g0/0/1(外网接口)的ip访问外网

STP 生成树协议,可以避免网络环路产生的广播风暴,达到保护网络的效果,还可以具有备份链路的作用

VRRP 虚拟路由冗余协议 
用来实现网关备份,通过虚拟路由器自动分配正真转发数据的节点(某台物理网关设备)
VRRP 成员
1, 主路由器,正在负责数据转发的设备
2, 备份路由器,处于监视状态,主路由器出现故障后立刻被其替代
3, 虚拟路由器,真正充当客户机网关的设备

MS1(左边的S5700)
in vlan 1  //进vlan1接口
ip add 192.168.1.252 24  //配ip
vlan 2   //创建vlan2
in vlan 2   //进vlan2接口
ip add 192.168.2.2 24  //配ip
in g0/0/1   //进接口
port link-type access
port default vlan 2  //加入vlan2
MS2
in vlan 1  //进vlan1接口
ip add 192.168.1.253 24  //配ip
vlan 3   //创建vlan3
in vlan 3   //进vlan3接口
ip add 192.168.3.2 24  //配ip
in g0/0/1   //进接口
port link-type access
port default vlan 3  //加入vlan3

dispaly ip interface brief  //查看ip

MS1
ospf
area 0
network 192.168.1.0 0.0.0.255
network 192.168.2.0 0.0.0.255
MS2
ospf
area 0
network 192.168.1.0 0.0.0.255
network 192.168.3.0 0.0.0.255
R(路由器)
ospf
area 0
network 192.168.2.0 0.0.0.255
network 192.168.3.0 0.0.0.255
network 192.168.4.0 0.0.0.255

使用查看路由表命令验证结果
可以只查看含有/24的行
display ip routing-table | include /24
可以临时让1.1使用1.252或者1.253作为网关
可以ping通4.1即可

在两台s5700配置vrrp功能
in vlan 1
vrrp vrid 1 virtual-ip 192.168.1.254   //
配置vrrp功能,组号1,虚拟路由器ip为192.168.1.254

display vrrp brief   //查看vrrp状态,两台设备
				应该是一主(master)一备(backup)
最后将1.1的网关设置为1.254测试全网互通即可

新增加vlan(部门)
MS1
vlan 10
in vlan 10
ip add 192.168.10.252 24
MS2
vlan 10
in vlan 10
ip add 192.168.10.253 24

将三层交换机与新部门之间的链路配置为trunk
MS1与MS2以及新部门交换机(SW2)相连的接口
in g0/0/3
port link-type trunk
port trunk allow-pass vlan all

SW2
vlan 10    
in e0/0/3
port link-type access
port default vlan 10
使用10.1去ping192.168.10.252与10.253都可以通

在 MS1与MS2宣告10网段
ospf
area 0
network 192.168.10.0 0.0.0.255

开启vlan10的vrrp功能
MS1与MS2
in vlan 10
vrrp vrid 10 virtual-ip 192.168.10.254

使用vrrp实现负载均衡
最终需要使MS1成为vlan1的主,MS2成为vlan10的主
MS1
in vlan 1   //进入MS1的vlan1接口
vrrp vrid 1 priority 105   //修改优先级为105,立刻成为vlan1的主
MS2
in vlan 10  //进入MS2的vlan10接口
vrrp vrid 10 priority 105  //修改优先级为105,立刻成为vlan10的主

##########################################
network day 05                          #
########################################
vlan trunk 链路聚合  stp ospf 静态路由  默认路由  acl vrrp nat

组建大型企业网络

1,规划vlan,每台交换机分别创建vlan10 20 30 40
	vlan batch 10 20 30 40
2,将每台主机链接的交换机接口加入所在的vlan
   sw1 进入0/0/1接口加入vlan10
	    in e0/0/1
		port link-type access
		port default vlan 10
3,将交换机与三层设备链接的链路配置为trunk
	sw1~sw3
	port-group 1  //创建接口组,为了方便在多个接口实现相同命令
	group-member ethernet 0/0/21 ethernet 0/0/22
	port link-type trunk
	port trunk allow-pass vlan all
	sw4
	interface eth-trunk 1   //创建链路聚合接口1
	trunkport ethernet 0/0/19 0/0/20  //将19和20号口捆一起
	port link-type trunk  //将聚合接口1配置为trunk
	port trunk allow-pass vlan all  //允许所有vlan通过
	interface eth-trunk 2   //创建链路聚合接口2
	trunkport ethernet 0/0/21 0/0/22  //将21和22号口捆一起
	port link-type trunk
	port trunk allow-pass vlan all

4,添加2台三层交换机,重命名ms1 与 ms2,同时创建之前的4个vlan
	sysname ms1
   	vlan batch 10 20 30 40
    port-group 1  //创建接口组,为了方便在多个接口实现相同命令
	group-member g0/0/1 to g0/0/3 g0/0/6  //添加了4个口
	port link-type trunk    //给这个4个口都配成trunk
	port trunk allow-pass vlan all
	ms1与ms2
	interface eth-trunk 1   //创建链路聚合接口1
	trunkport gigabitethernet 0/0/4 0/0/5  //将4和5号口捆一起
	port link-type trunk
	port trunk allow-pass vlan all	

5,为三层交换机配置ip,并测试
	ms1配置252 , ms2都把252改成253
	in vlan 10  
	ip add 192.168.10.252 24
	in vlan 20  
	ip add 192.168.20.252 24
	in vlan 30  
	ip add 192.168.30.252 24
	in vlan 30  
	ip add 192.168.40.252 24

display ip interface brief    //查看所有配置的ip地址

6,配置vrrp实现虚拟网关
ms1成为vlan10与20的主
	in vlan 10
	vrrp vrid 10 virtual-ip 192.168.10.254
	vrrp vrid 10 priority 105  //提高优先级,在vlan10保持主的身份
	in vlan 20
	vrrp vrid 20 virtual-ip 192.168.20.254
	vrrp vrid 20 priority 105  //提高优先级,在vlan20保持主的身份
	in vlan 30
	vrrp vrid 30 virtual-ip 192.168.30.254
	in vlan 40
	vrrp vrid 40 virtual-ip 192.168.40.254
ms2成为vlan30与40的主
	in vlan 10
	vrrp vrid 10 virtual-ip 192.168.10.254
	in vlan 20
	vrrp vrid 20 virtual-ip 192.168.20.254
	in vlan 30
	vrrp vrid 30 virtual-ip 192.168.30.254
	vrrp vrid 30 priority 105  //提高优先级,在vlan30保持主的身份
	in vlan 40
	vrrp vrid 40 virtual-ip 192.168.40.254
	vrrp vrid 40 priority 105  //提高优先级,在vlan40保持主的身份

排错: 1,首先检查所有ip,子网掩码与网关 , 然后查看所有交换机是否都创建了4个vlan, 所有交换机之间所链接的链路是否全是trunk

7,为三层交换机外网出口配置ip
	ms1
	vlan batch 50 60
	in vlan 50
	ip add 192.168.50.2 24
	in g0/0/7
	port link-type access
	port default vlan 50
	in vlan 60
	ip add 192.168.60.2 24
	in g0/0/8
	port link-type access
	port default vlan 60
	ms2
	vlan batch 70 80
	in vlan 70
	ip add 192.168.70.2 24
	in g0/0/7
	port link-type access
	port default vlan 70
	in vlan 80
	ip add 192.168.80.2 24
	in g0/0/8
	port link-type access
	port default vlan 80

8,同时为路由器配置对应ip
9,为三层交换机开启ospf
	ms1
	ospf
	area 0
	network 192.168.10.0 0.0.0.255
	network 192.168.20.0 0.0.0.255
	network 192.168.30.0 0.0.0.255
	network 192.168.40.0 0.0.0.255
	network 192.168.50.0 0.0.0.255
	network 192.168.60.0 0.0.0.255
	ms2
	ospf
	area 0
	network 192.168.10.0 0.0.0.255
	network 192.168.20.0 0.0.0.255
	network 192.168.30.0 0.0.0.255
	network 192.168.40.0 0.0.0.255
	network 192.168.70.0 0.0.0.255
	network 192.168.80.0 0.0.0.255
	R1
	ospf
	area 0
	network 192.168.50.0 0.0.0.255
	network 192.168.70.0 0.0.0.255
	R2
	ospf
	area 0
	network 192.168.60.0 0.0.0.255
	network 192.168.80.0 0.0.0.255
10,添加外部网络,外网设备使用3700交换机
	路由器链接外网的接口配置ip
	然后配置默认路由
	R1与R2
	ip route-static 0.0.0.0 0 100.0.0.10  //配置默认路由
	ospf
	default-route-advertise   //对外通告默认路由
11,配置nat让内外互通
	R1与R2
	acl 2000   //创建acl确定谁可以访问外网的主机
	rule permit source any   //任何人都可以
	in g0/0/2
	nat outbound 2000  //进入接口开启nat,列表2000中是所有人

